I0219 07:00:20.547380  441708 vertexai.go:238] "sending LLM request" user=["\"You are a very good golang programmer and good at doing tasks.Your task is to make the given go code compilable:- run go build ./pkg/controller/direct/migrationcenter/... and fix all the errors.- run go build ./apis/migrationcenter/v1alpha1/... and fix all the errors.- Edit the existing files if needed.- Add new files if needed. New file should only be added under ./apis/migrationcenter/v1alpha1/ or ./pkg/controller/direct/migrationcenter/ directories.- Retry max to 10 times or until you succeed. - Once you fixed the go build errors, print the message in Json format- If you see imported ... not used, you should remove the unused import package.{status: success}\""]
running *ui.BashUI: error running callback: generating content with gemini: sending message to LLM: rpc error: code = PermissionDenied desc = Permission 'aiplatform.endpoints.predict' denied on resource '//aiplatform.googleapis.com/projects/migrationcenter-group-19/locations/us-central1/publishers/google/models/gemini-2.0-pro-exp-02-05' (or it may not exist).
error details: name = ErrorInfo reason = IAM_PERMISSION_DENIED domain = aiplatform.googleapis.com metadata = map[permission:aiplatform.endpoints.predict resource:projects/migrationcenter-group-19/locations/us-central1/publishers/google/models/gemini-2.0-pro-exp-02-05]
error details: name = DebugInfo detail = NOT_FOUND: The project id 'migrationcenter-group-19' is not found. stack =
I0219 07:00:32.640856  452338 vertexai.go:238] "sending LLM request" user=["\"You are a very good golang programmer and good at doing tasks.Your task is to make the given go code compilable:- run go build ./pkg/controller/direct/migrationcenter/... and fix all the errors.- run go build ./apis/migrationcenter/v1alpha1/... and fix all the errors.- Edit the existing files if needed.- Add new files if needed. New file should only be added under ./apis/migrationcenter/v1alpha1/ or ./pkg/controller/direct/migrationcenter/ directories.- Retry max to 10 times or until you succeed. - Once you fixed the go build errors, print the message in Json format- If you see imported ... not used, you should remove the unused import package.{status: success}\""]
running *ui.BashUI: error running callback: generating content with gemini: sending message to LLM: rpc error: code = PermissionDenied desc = Permission 'aiplatform.endpoints.predict' denied on resource '//aiplatform.googleapis.com/projects/migrationcenter-group-19/locations/us-central1/publishers/google/models/gemini-2.0-pro-exp-02-05' (or it may not exist).
error details: name = ErrorInfo reason = IAM_PERMISSION_DENIED domain = aiplatform.googleapis.com metadata = map[permission:aiplatform.endpoints.predict resource:projects/migrationcenter-group-19/locations/us-central1/publishers/google/models/gemini-2.0-pro-exp-02-05]
error details: name = DebugInfo detail = NOT_FOUND: The project id 'migrationcenter-group-19' is not found. stack =
I0219 07:00:42.426206  460137 vertexai.go:238] "sending LLM request" user=["\"You are a very good golang programmer and good at doing tasks.Your task is to make the given go code compilable:- run go build ./pkg/controller/direct/migrationcenter/... and fix all the errors.- run go build ./apis/migrationcenter/v1alpha1/... and fix all the errors.- Edit the existing files if needed.- Add new files if needed. New file should only be added under ./apis/migrationcenter/v1alpha1/ or ./pkg/controller/direct/migrationcenter/ directories.- Retry max to 10 times or until you succeed. - Once you fixed the go build errors, print the message in Json format- If you see imported ... not used, you should remove the unused import package.{status: success}\""]
I0219 07:00:50.885471  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:853 CandidatesTokenCount:57 TotalTokenCount:910}
I0219 07:00:50.885506  460137 chat.go:107] processing candidate &{candidate:0xc00399f950}
Okay, I will try to compile the code and fix any errors. I will start by trying to build the code in the `./pkg/controller/direct/migrationcenter/...` directory.


functionCall: {Name:RunTerminalCommand Arguments:map[args:build ./pkg/controller/direct/migrationcenter/... command:go]}
sending response: {"error":"command failed with exit code 1: ","output":"pkg/controller/direct/migrationcenter/group_controller.go:30:2: no required module provides package cloud.google.com/go/migrationcenter/apiv1; to add it:\n\tgo get cloud.google.com/go/migrationcenter/apiv1\npkg/controller/direct/migrationcenter/mapper.generated.go:18:2: no required module provides package cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb; to add it:\n\tgo get cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:33:2: no required module provides package cloud.google.com/go/migrationcenter/v1/migrationcenterpb; to add it:\n\tgo get cloud.google.com/go/migrationcenter/v1/migrationcenterpb\n","success":false}
I0219 07:00:51.120485  460137 chat.go:157] functionResponses: [{Name:RunTerminalCommand Result:map[error:command failed with exit code 1:  output:pkg/controller/direct/migrationcenter/group_controller.go:30:2: no required module provides package cloud.google.com/go/migrationcenter/apiv1; to add it:
	go get cloud.google.com/go/migrationcenter/apiv1
pkg/controller/direct/migrationcenter/mapper.generated.go:18:2: no required module provides package cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb; to add it:
	go get cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:33:2: no required module provides package cloud.google.com/go/migrationcenter/v1/migrationcenterpb; to add it:
	go get cloud.google.com/go/migrationcenter/v1/migrationcenterpb
 success:false]}]
I0219 07:01:00.061092  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1128 CandidatesTokenCount:91 TotalTokenCount:1219}
I0219 07:01:00.061124  460137 chat.go:107] processing candidate &{candidate:0xc0028b2640}
It seems like there are some missing dependencies. I will try to fetch them using `go get`.


functionCall: {Name:RunTerminalCommand Arguments:map[args:get cloud.google.com/go/migrationcenter/apiv1 command:go]}
sending response: {"error":"","output":"go: added cloud.google.com/go/migrationcenter v1.1.3\n","success":true}
functionCall: {Name:RunTerminalCommand Arguments:map[args:get cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb command:go]}
sending response: {"error":"","output":"","success":true}
functionCall: {Name:RunTerminalCommand Arguments:map[args:get cloud.google.com/go/migrationcenter/v1/migrationcenterpb command:go]}
sending response: {"error":"command failed with exit code 1: ","output":"go: module cloud.google.com/go/migrationcenter@upgrade found (v1.1.3), but does not contain package cloud.google.com/go/migrationcenter/v1/migrationcenterpb\n","success":false}
I0219 07:01:00.518217  460137 chat.go:157] functionResponses: [{Name:RunTerminalCommand Result:map[error: output:go: added cloud.google.com/go/migrationcenter v1.1.3
 success:true]} {Name:RunTerminalCommand Result:map[error: output: success:true]} {Name:RunTerminalCommand Result:map[error:command failed with exit code 1:  output:go: module cloud.google.com/go/migrationcenter@upgrade found (v1.1.3), but does not contain package cloud.google.com/go/migrationcenter/v1/migrationcenterpb
 success:false]}]
I0219 07:01:09.401458  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1313 CandidatesTokenCount:118 TotalTokenCount:1431}
I0219 07:01:09.401484  460137 chat.go:107] processing candidate &{candidate:0xc003f559f0}
It seems like the last `go get` command failed. The package `cloud.google.com/go/migrationcenter/v1/migrationcenterpb` doesn't exist in the `v1.1.3` module. I'll try to use `cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb` instead, as suggested before and re-run the build command for `./pkg/controller/direct/migrationcenter/...`.


functionCall: {Name:RunTerminalCommand Arguments:map[args:build ./pkg/controller/direct/migrationcenter/... command:go]}
sending response: {"error":"command failed with exit code 1: ","output":"pkg/controller/direct/migrationcenter/group_controller.go:33:2: no required module provides package cloud.google.com/go/migrationcenter/v1/migrationcenterpb; to add it:\n\tgo get cloud.google.com/go/migrationcenter/v1/migrationcenterpb\n","success":false}
I0219 07:01:09.662675  460137 chat.go:157] functionResponses: [{Name:RunTerminalCommand Result:map[error:command failed with exit code 1:  output:pkg/controller/direct/migrationcenter/group_controller.go:33:2: no required module provides package cloud.google.com/go/migrationcenter/v1/migrationcenterpb; to add it:
	go get cloud.google.com/go/migrationcenter/v1/migrationcenterpb
 success:false]}]
I0219 07:01:18.493352  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1515 CandidatesTokenCount:83 TotalTokenCount:1598}
I0219 07:01:18.493384  460137 chat.go:107] processing candidate &{candidate:0xc0028b3040}
It seems like I still have an error related to the package `cloud.google.com/go/migrationcenter/v1/migrationcenterpb`. Since I couldn't find `v1` in the previous `go get` attempts. I will remove this import and the usage.

functionCall: {Name:FindInWorkspace Arguments:map[find_text:cloud.google.com/go/migrationcenter/v1/migrationcenterpb]}
sending response: {"matches":[{"context":"31: \n32: \t// TODO(contributor): Update the import with the google cloud client api protobuf\n33: \tmigrationcenterpb \"cloud.google.com/go/migrationcenter/v1/migrationcenterpb\"\n34: \t\"google.golang.org/api/option\"\n35: \t\"google.golang.org/protobuf/types/known/fieldmaskpb\"\n","filename":"pkg/controller/direct/migrationcenter/group_controller.go","matching_line":"\tmigrationcenterpb \"cloud.google.com/go/migrationcenter/v1/migrationcenterpb\""}],"result":"success"}
I0219 07:01:18.929264  460137 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:[map[context:31: 
32: 	// TODO(contributor): Update the import with the google cloud client api protobuf
33: 	migrationcenterpb "cloud.google.com/go/migrationcenter/v1/migrationcenterpb"
34: 	"google.golang.org/api/option"
35: 	"google.golang.org/protobuf/types/known/fieldmaskpb"
 filename:pkg/controller/direct/migrationcenter/group_controller.go matching_line:	migrationcenterpb "cloud.google.com/go/migrationcenter/v1/migrationcenterpb"]] result:success]}]
I0219 07:01:28.149160  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1740 CandidatesTokenCount:126 TotalTokenCount:1866}
I0219 07:01:28.149198  460137 chat.go:107] processing candidate &{candidate:0xc00032c140}
functionCall: {Name:EditFile Arguments:map[existing_text:	// TODO(contributor): Update the import with the google cloud client api protobuf
	migrationcenterpb "cloud.google.com/go/migrationcenter/v1/migrationcenterpb"
	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb" filename:pkg/controller/direct/migrationcenter/group_controller.go new_text:	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"]}
I0219 07:01:28.149451  460137 tool_edit_file.go:116] wrote /usr/local/google/home/yuwenma/go/src/github.com/GoogleCloudPlatform/migrationcenter-Group/pkg/controller/direct/migrationcenter/group_controller.go: // Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package migrationcenter

import (
	"context"
	"fmt"

	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"

	// TODO(contributor): Update the import with the google cloud client
	gcp "cloud.google.com/go/migrationcenter/apiv1"

	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func init() {
	registry.RegisterModel(krm.MigrationcenterGroupGVK, NewGroupModel)
}

func NewGroupModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
	return &modelGroup{config: *config}, nil
}

var _ directbase.Model = &modelGroup{}

type modelGroup struct {
	config config.ControllerConfig
}

func (m *modelGroup) client(ctx context.Context) (*gcp.Client, error) {
	var opts []option.ClientOption
	opts, err := m.config.RESTClientOptions()
	if err != nil {
		return nil, err
	}
	gcpClient, err := gcp.NewRESTClient(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("building Group client: %w", err)
	}
	return gcpClient, err
}

func (m *modelGroup) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
	obj := &krm.MigrationcenterGroup{}
	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &obj); err != nil {
		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
	}

	id, err := krm.NewGroupIdentity(ctx, reader, obj)
	if err != nil {
		return nil, err
	}

	// Get migrationcenter GCP client
	gcpClient, err := m.client(ctx)
	if err != nil {
		return nil, err
	}
	return &GroupAdapter{
		id:        id,
		gcpClient: gcpClient,
		desired:   obj,
	}, nil
}

func (m *modelGroup) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
	// TODO: Support URLs
	return nil, nil
}

type GroupAdapter struct {
	id        *krm.GroupIdentity
	gcpClient *gcp.Client
	desired   *krm.MigrationcenterGroup
	actual    *migrationcenterpb.Group
}

var _ directbase.Adapter = &GroupAdapter{}

// Find retrieves the GCP resource.
// Return true means the object is found. This triggers Adapter `Update` call.
// Return false means the object is not found. This triggers Adapter `Create` call.
// Return a non-nil error requeues the requests.
func (a *GroupAdapter) Find(ctx context.Context) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("getting Group", "name", a.id)

	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
	grouppb, err := a.gcpClient.GetGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			return false, nil
		}
		return false, fmt.Errorf("getting Group %q: %w", a.id, err)
	}

	a.actual = grouppb
	return true, nil
}

// Create creates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("creating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desired := a.desired.DeepCopy()
	resource := MigrationcenterGroupSpec_ToProto(mapCtx, &desired.Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	// TODO(contributor): Complete the gcp "CREATE" or "INSERT" request.
	req := &migrationcenterpb.CreateGroupRequest{
		Parent: a.id.Parent().String(),
		Group:  resource,
	}
	op, err := a.gcpClient.CreateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("creating Group %s: %w", a.id, err)
	}
	created, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting creation: %w", a.id, err)
	}
	log.V(2).Info("successfully created Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, created)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	status.ExternalRef = direct.LazyPtr(a.id.String())
	return createOp.UpdateStatus(ctx, status, nil)
}

// Update updates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("updating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desiredPb := MigrationcenterGroupSpec_ToProto(mapCtx, &a.desired.DeepCopy().Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	var err error
	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
	if err != nil {
		return err
	}
	if len(paths) == 0 {
		log.V(2).Info("no field needs update", "name", a.id)
		status := &krm.MigrationcenterGroupStatus{}
		status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, a.actual)
		if mapCtx.Err() != nil {
			return mapCtx.Err()
		}
		return updateOp.UpdateStatus(ctx, status, nil)
	}
	updateMask := &fieldmaskpb.FieldMask{
		Paths: sets.List(paths)}

	// TODO(contributor): Complete the gcp "UPDATE" or "PATCH" request.
	req := &migrationcenterpb.UpdateGroupRequest{
		Name:       a.id,
		UpdateMask: updateMask,
		Group:      desiredPb,
	}
	op, err := a.gcpClient.UpdateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("updating Group %s: %w", a.id, err)
	}
	updated, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting update: %w", a.id, err)
	}
	log.V(2).Info("successfully updated Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, updated)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	return updateOp.UpdateStatus(ctx, status, nil)
}

// Export maps the GCP object to a Config Connector resource `spec`.
func (a *GroupAdapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
	if a.actual == nil {
		return nil, fmt.Errorf("Find() not called")
	}
	u := &unstructured.Unstructured{}

	obj := &krm.MigrationcenterGroup{}
	mapCtx := &direct.MapContext{}
	obj.Spec = direct.ValueOf(MigrationcenterGroupSpec_FromProto(mapCtx, a.actual))
	if mapCtx.Err() != nil {
		return nil, mapCtx.Err()
	}
	obj.Spec.ProjectRef = &refs.ProjectRef{External: a.id.Parent().ProjectID}
	obj.Spec.Location = a.id.Parent().Location
	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
	if err != nil {
		return nil, err
	}

	u.SetName(a.actual.Id)
	u.SetGroupVersionKind(krm.MigrationcenterGroupGVK)

	u.Object = uObj
	return u, nil
}

// Delete the resource from GCP service when the corresponding Config Connector resource is deleted.
func (a *GroupAdapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("deleting Group", "name", a.id)

	req := &migrationcenterpb.DeleteGroupRequest{Name: a.id.String()}
	op, err := a.gcpClient.DeleteGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			// Return success if not found (assume it was already deleted).
			log.V(2).Info("skipping delete for non-existent Group, assuming it was already deleted", "name", a.id.String())
			return true, nil
		}
		return false, fmt.Errorf("deleting Group %s: %w", a.id, err)
	}
	log.V(2).Info("successfully deleted Group", "name", a.id)

	err = op.Wait(ctx)
	if err != nil {
		return false, fmt.Errorf("waiting delete Group %s: %w", a.id, err)
	}
	return true, nil
}
sending response: {"success":true}
I0219 07:01:28.149485  460137 chat.go:157] functionResponses: [{Name:EditFile Result:map[success:true]}]
I0219 07:01:36.405877  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1869 CandidatesTokenCount:22 TotalTokenCount:1891}
I0219 07:01:36.405912  460137 chat.go:107] processing candidate &{candidate:0xc008db42d0}
Now I will remove any references to this removed package.


functionCall: {Name:FindInWorkspace Arguments:map[find_text:migrationcenterpb.]}
sending response: {"matches":[{"context":"99: \tgcpClient *gcp.Client\n100: \tdesired   *krm.MigrationcenterGroup\n101: \tactual    *migrationcenterpb.Group\n102: }\n103: \n","filename":"pkg/controller/direct/migrationcenter/group_controller.go","matching_line":"\tactual    *migrationcenterpb.Group"}],"result":"success"}
I0219 07:01:36.825433  460137 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:[map[context:99: 	gcpClient *gcp.Client
100: 	desired   *krm.MigrationcenterGroup
101: 	actual    *migrationcenterpb.Group
102: }
103: 
 filename:pkg/controller/direct/migrationcenter/group_controller.go matching_line:	actual    *migrationcenterpb.Group]] result:success]}]
I0219 07:01:45.053467  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:1980 CandidatesTokenCount:43 TotalTokenCount:2023}
I0219 07:01:45.053512  460137 chat.go:107] processing candidate &{candidate:0xc00032d630}
functionCall: {Name:EditFile Arguments:map[existing_text:	actual    *migrationcenterpb.Group filename:pkg/controller/direct/migrationcenter/group_controller.go new_text:	actual    *migrationcenterapiv1.Group]}
I0219 07:01:45.053675  460137 tool_edit_file.go:116] wrote /usr/local/google/home/yuwenma/go/src/github.com/GoogleCloudPlatform/migrationcenter-Group/pkg/controller/direct/migrationcenter/group_controller.go: // Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package migrationcenter

import (
	"context"
	"fmt"

	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"

	// TODO(contributor): Update the import with the google cloud client
	gcp "cloud.google.com/go/migrationcenter/apiv1"

	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func init() {
	registry.RegisterModel(krm.MigrationcenterGroupGVK, NewGroupModel)
}

func NewGroupModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
	return &modelGroup{config: *config}, nil
}

var _ directbase.Model = &modelGroup{}

type modelGroup struct {
	config config.ControllerConfig
}

func (m *modelGroup) client(ctx context.Context) (*gcp.Client, error) {
	var opts []option.ClientOption
	opts, err := m.config.RESTClientOptions()
	if err != nil {
		return nil, err
	}
	gcpClient, err := gcp.NewRESTClient(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("building Group client: %w", err)
	}
	return gcpClient, err
}

func (m *modelGroup) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
	obj := &krm.MigrationcenterGroup{}
	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &obj); err != nil {
		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
	}

	id, err := krm.NewGroupIdentity(ctx, reader, obj)
	if err != nil {
		return nil, err
	}

	// Get migrationcenter GCP client
	gcpClient, err := m.client(ctx)
	if err != nil {
		return nil, err
	}
	return &GroupAdapter{
		id:        id,
		gcpClient: gcpClient,
		desired:   obj,
	}, nil
}

func (m *modelGroup) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
	// TODO: Support URLs
	return nil, nil
}

type GroupAdapter struct {
	id        *krm.GroupIdentity
	gcpClient *gcp.Client
	desired   *krm.MigrationcenterGroup
	actual    *migrationcenterapiv1.Group
}

var _ directbase.Adapter = &GroupAdapter{}

// Find retrieves the GCP resource.
// Return true means the object is found. This triggers Adapter `Update` call.
// Return false means the object is not found. This triggers Adapter `Create` call.
// Return a non-nil error requeues the requests.
func (a *GroupAdapter) Find(ctx context.Context) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("getting Group", "name", a.id)

	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
	grouppb, err := a.gcpClient.GetGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			return false, nil
		}
		return false, fmt.Errorf("getting Group %q: %w", a.id, err)
	}

	a.actual = grouppb
	return true, nil
}

// Create creates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("creating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desired := a.desired.DeepCopy()
	resource := MigrationcenterGroupSpec_ToProto(mapCtx, &desired.Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	// TODO(contributor): Complete the gcp "CREATE" or "INSERT" request.
	req := &migrationcenterpb.CreateGroupRequest{
		Parent: a.id.Parent().String(),
		Group:  resource,
	}
	op, err := a.gcpClient.CreateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("creating Group %s: %w", a.id, err)
	}
	created, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting creation: %w", a.id, err)
	}
	log.V(2).Info("successfully created Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, created)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	status.ExternalRef = direct.LazyPtr(a.id.String())
	return createOp.UpdateStatus(ctx, status, nil)
}

// Update updates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("updating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desiredPb := MigrationcenterGroupSpec_ToProto(mapCtx, &a.desired.DeepCopy().Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	var err error
	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
	if err != nil {
		return err
	}
	if len(paths) == 0 {
		log.V(2).Info("no field needs update", "name", a.id)
		status := &krm.MigrationcenterGroupStatus{}
		status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, a.actual)
		if mapCtx.Err() != nil {
			return mapCtx.Err()
		}
		return updateOp.UpdateStatus(ctx, status, nil)
	}
	updateMask := &fieldmaskpb.FieldMask{
		Paths: sets.List(paths)}

	// TODO(contributor): Complete the gcp "UPDATE" or "PATCH" request.
	req := &migrationcenterpb.UpdateGroupRequest{
		Name:       a.id,
		UpdateMask: updateMask,
		Group:      desiredPb,
	}
	op, err := a.gcpClient.UpdateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("updating Group %s: %w", a.id, err)
	}
	updated, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting update: %w", a.id, err)
	}
	log.V(2).Info("successfully updated Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, updated)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	return updateOp.UpdateStatus(ctx, status, nil)
}

// Export maps the GCP object to a Config Connector resource `spec`.
func (a *GroupAdapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
	if a.actual == nil {
		return nil, fmt.Errorf("Find() not called")
	}
	u := &unstructured.Unstructured{}

	obj := &krm.MigrationcenterGroup{}
	mapCtx := &direct.MapContext{}
	obj.Spec = direct.ValueOf(MigrationcenterGroupSpec_FromProto(mapCtx, a.actual))
	if mapCtx.Err() != nil {
		return nil, mapCtx.Err()
	}
	obj.Spec.ProjectRef = &refs.ProjectRef{External: a.id.Parent().ProjectID}
	obj.Spec.Location = a.id.Parent().Location
	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
	if err != nil {
		return nil, err
	}

	u.SetName(a.actual.Id)
	u.SetGroupVersionKind(krm.MigrationcenterGroupGVK)

	u.Object = uObj
	return u, nil
}

// Delete the resource from GCP service when the corresponding Config Connector resource is deleted.
func (a *GroupAdapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("deleting Group", "name", a.id)

	req := &migrationcenterpb.DeleteGroupRequest{Name: a.id.String()}
	op, err := a.gcpClient.DeleteGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			// Return success if not found (assume it was already deleted).
			log.V(2).Info("skipping delete for non-existent Group, assuming it was already deleted", "name", a.id.String())
			return true, nil
		}
		return false, fmt.Errorf("deleting Group %s: %w", a.id, err)
	}
	log.V(2).Info("successfully deleted Group", "name", a.id)

	err = op.Wait(ctx)
	if err != nil {
		return false, fmt.Errorf("waiting delete Group %s: %w", a.id, err)
	}
	return true, nil
}
sending response: {"success":true}
I0219 07:01:45.053700  460137 chat.go:157] functionResponses: [{Name:EditFile Result:map[success:true]}]
I0219 07:01:53.221281  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:2026 CandidatesTokenCount:36 TotalTokenCount:2062}
I0219 07:01:53.221331  460137 chat.go:107] processing candidate &{candidate:0xc008db4230}
I need to replace the import alias.

functionCall: {Name:FindInWorkspace Arguments:map[find_text:migrationcenterapiv1 "cloud.google.com/go/migrationcenter/apiv1"]}
sending response: {"matches":null,"result":"success"}
I0219 07:01:53.670134  460137 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:<nil> result:success]}]
I0219 07:02:02.058649  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:2068 CandidatesTokenCount:60 TotalTokenCount:2128}
I0219 07:02:02.058689  460137 chat.go:107] processing candidate &{candidate:0xc00032c1e0}
functionCall: {Name:EditFile Arguments:map[existing_text:import (
	"context" filename:pkg/controller/direct/migrationcenter/group_controller.go new_text:import (
	migrationcenterapiv1 "cloud.google.com/go/migrationcenter/apiv1"
	"context"]}
I0219 07:02:02.058967  460137 tool_edit_file.go:116] wrote /usr/local/google/home/yuwenma/go/src/github.com/GoogleCloudPlatform/migrationcenter-Group/pkg/controller/direct/migrationcenter/group_controller.go: // Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package migrationcenter

import (
	migrationcenterapiv1 "cloud.google.com/go/migrationcenter/apiv1"
	"context"
	"fmt"

	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"

	// TODO(contributor): Update the import with the google cloud client
	gcp "cloud.google.com/go/migrationcenter/apiv1"

	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func init() {
	registry.RegisterModel(krm.MigrationcenterGroupGVK, NewGroupModel)
}

func NewGroupModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
	return &modelGroup{config: *config}, nil
}

var _ directbase.Model = &modelGroup{}

type modelGroup struct {
	config config.ControllerConfig
}

func (m *modelGroup) client(ctx context.Context) (*gcp.Client, error) {
	var opts []option.ClientOption
	opts, err := m.config.RESTClientOptions()
	if err != nil {
		return nil, err
	}
	gcpClient, err := gcp.NewRESTClient(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("building Group client: %w", err)
	}
	return gcpClient, err
}

func (m *modelGroup) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
	obj := &krm.MigrationcenterGroup{}
	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &obj); err != nil {
		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
	}

	id, err := krm.NewGroupIdentity(ctx, reader, obj)
	if err != nil {
		return nil, err
	}

	// Get migrationcenter GCP client
	gcpClient, err := m.client(ctx)
	if err != nil {
		return nil, err
	}
	return &GroupAdapter{
		id:        id,
		gcpClient: gcpClient,
		desired:   obj,
	}, nil
}

func (m *modelGroup) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
	// TODO: Support URLs
	return nil, nil
}

type GroupAdapter struct {
	id        *krm.GroupIdentity
	gcpClient *gcp.Client
	desired   *krm.MigrationcenterGroup
	actual    *migrationcenterapiv1.Group
}

var _ directbase.Adapter = &GroupAdapter{}

// Find retrieves the GCP resource.
// Return true means the object is found. This triggers Adapter `Update` call.
// Return false means the object is not found. This triggers Adapter `Create` call.
// Return a non-nil error requeues the requests.
func (a *GroupAdapter) Find(ctx context.Context) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("getting Group", "name", a.id)

	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
	grouppb, err := a.gcpClient.GetGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			return false, nil
		}
		return false, fmt.Errorf("getting Group %q: %w", a.id, err)
	}

	a.actual = grouppb
	return true, nil
}

// Create creates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("creating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desired := a.desired.DeepCopy()
	resource := MigrationcenterGroupSpec_ToProto(mapCtx, &desired.Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	// TODO(contributor): Complete the gcp "CREATE" or "INSERT" request.
	req := &migrationcenterpb.CreateGroupRequest{
		Parent: a.id.Parent().String(),
		Group:  resource,
	}
	op, err := a.gcpClient.CreateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("creating Group %s: %w", a.id, err)
	}
	created, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting creation: %w", a.id, err)
	}
	log.V(2).Info("successfully created Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, created)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	status.ExternalRef = direct.LazyPtr(a.id.String())
	return createOp.UpdateStatus(ctx, status, nil)
}

// Update updates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("updating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desiredPb := MigrationcenterGroupSpec_ToProto(mapCtx, &a.desired.DeepCopy().Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	var err error
	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
	if err != nil {
		return err
	}
	if len(paths) == 0 {
		log.V(2).Info("no field needs update", "name", a.id)
		status := &krm.MigrationcenterGroupStatus{}
		status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, a.actual)
		if mapCtx.Err() != nil {
			return mapCtx.Err()
		}
		return updateOp.UpdateStatus(ctx, status, nil)
	}
	updateMask := &fieldmaskpb.FieldMask{
		Paths: sets.List(paths)}

	// TODO(contributor): Complete the gcp "UPDATE" or "PATCH" request.
	req := &migrationcenterpb.UpdateGroupRequest{
		Name:       a.id,
		UpdateMask: updateMask,
		Group:      desiredPb,
	}
	op, err := a.gcpClient.UpdateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("updating Group %s: %w", a.id, err)
	}
	updated, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting update: %w", a.id, err)
	}
	log.V(2).Info("successfully updated Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, updated)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	return updateOp.UpdateStatus(ctx, status, nil)
}

// Export maps the GCP object to a Config Connector resource `spec`.
func (a *GroupAdapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
	if a.actual == nil {
		return nil, fmt.Errorf("Find() not called")
	}
	u := &unstructured.Unstructured{}

	obj := &krm.MigrationcenterGroup{}
	mapCtx := &direct.MapContext{}
	obj.Spec = direct.ValueOf(MigrationcenterGroupSpec_FromProto(mapCtx, a.actual))
	if mapCtx.Err() != nil {
		return nil, mapCtx.Err()
	}
	obj.Spec.ProjectRef = &refs.ProjectRef{External: a.id.Parent().ProjectID}
	obj.Spec.Location = a.id.Parent().Location
	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
	if err != nil {
		return nil, err
	}

	u.SetName(a.actual.Id)
	u.SetGroupVersionKind(krm.MigrationcenterGroupGVK)

	u.Object = uObj
	return u, nil
}

// Delete the resource from GCP service when the corresponding Config Connector resource is deleted.
func (a *GroupAdapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("deleting Group", "name", a.id)

	req := &migrationcenterpb.DeleteGroupRequest{Name: a.id.String()}
	op, err := a.gcpClient.DeleteGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			// Return success if not found (assume it was already deleted).
			log.V(2).Info("skipping delete for non-existent Group, assuming it was already deleted", "name", a.id.String())
			return true, nil
		}
		return false, fmt.Errorf("deleting Group %s: %w", a.id, err)
	}
	log.V(2).Info("successfully deleted Group", "name", a.id)

	err = op.Wait(ctx)
	if err != nil {
		return false, fmt.Errorf("waiting delete Group %s: %w", a.id, err)
	}
	return true, nil
}
sending response: {"success":true}
I0219 07:02:02.059007  460137 chat.go:157] functionResponses: [{Name:EditFile Result:map[success:true]}]
I0219 07:02:09.961460  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:2131 CandidatesTokenCount:17 TotalTokenCount:2148}
I0219 07:02:09.961492  460137 chat.go:107] processing candidate &{candidate:0xc00032c780}
functionCall: {Name:RunTerminalCommand Arguments:map[args:build ./pkg/controller/direct/migrationcenter/... command:go]}
sending response: {"error":"command failed with exit code 1: ","output":"# github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/migrationcenter\npkg/controller/direct/migrationcenter/group_controller.go:102:34: undefined: migrationcenterapiv1.Group\npkg/controller/direct/migrationcenter/group_controller.go:115:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:141:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:176:2: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:180:9: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:190:20: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:193:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:248:10: undefined: migrationcenterpb\n","success":false}
I0219 07:02:12.514679  460137 chat.go:157] functionResponses: [{Name:RunTerminalCommand Result:map[error:command failed with exit code 1:  output:# github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/migrationcenter
pkg/controller/direct/migrationcenter/group_controller.go:102:34: undefined: migrationcenterapiv1.Group
pkg/controller/direct/migrationcenter/group_controller.go:115:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:141:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:176:2: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:180:9: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:190:20: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:193:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:248:10: undefined: migrationcenterpb
 success:false]}]
I0219 07:02:21.309524  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:2409 CandidatesTokenCount:65 TotalTokenCount:2474}
I0219 07:02:21.309575  460137 chat.go:107] processing candidate &{candidate:0xc008db4ff0}
It seems that I still have errors. The errors `undefined: migrationcenterpb` are caused because I replaced the type but did not updated the following lines that use the `migrationcenterpb`. Also there are other undefined errors `undefined: paths`, so I will fix them.

functionCall: {Name:FindInWorkspace Arguments:map[find_text:paths]}
sending response: {"matches":[{"context":"191: \t}\n192: \n193: \t// a map of supported connection types to the corresponding status paths to service acocunt ID\n194: \tserviceAccountPaths := map[string][]string{\n195: \t\t\"cloudSQL\":      {\"status\", \"observedState\", \"cloudSQL\", \"serviceAccountID\"},\n","filename":"apis/bigqueryconnection/v1beta1/connection_reference.go","matching_line":"\t// a map of supported connection types to the corresponding status paths to service acocunt ID"},{"context":"102: \t}\n103: \n104: \t// For organization and folder paths, only expect 2 parts\n105: \tif parts[0] == \"organizations\" || parts[0] == \"folders\" {\n106: \t\tif len(parts) != 2 {\n","filename":"apis/iap/v1alpha1/iapsettings_identity.go","matching_line":"\t// For organization and folder paths, only expect 2 parts"},{"context":"75: \tProducerInstanceLocation *string `json:\"producerInstanceLocation,omitempty\"`\n76: \n77: \t// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.\n78: \tSubnetworks []refs.ComputeSubnetworkRef `json:\"subnetworkRefs,omitempty\"`\n79: }\n","filename":"apis/networkconnectivity/v1alpha1/serviceconnectionpolicy_types.go","matching_line":"\t// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}."},{"context":"937: \t\tcase \"containeranalysisnote\":\n938: \t\tcase \"dataproccluster\":\n939: \t\tcase \"cloudstoragepathstoredinfotype\":\n940: \t\tcase \"dnsrecordset\":\n941: \t\tcase \"eventarctrigger\":\n","filename":"config/tests/samples/create/harness.go","matching_line":"\t\tcase \"cloudstoragepathstoredinfotype\":"},{"context":"206: \t}\n207: \n208: \tpaths := []string{}\n209: \t// Option 1: This option is good for proto that has ` + \"`\" + `field_mask` + \"`\" + ` for output-only, immutable, required/optional.\n210: \t// TODO(contributor): If choosing this option, remove the \"Option 2\" code.\n","filename":"dev/tools/controllerbuilder/template/controller/controller.go","matching_line":"\tpaths := []string{}"},{"context":"15: package api\n16: \n17: //go:generate go run sigs.k8s.io/controller-tools/cmd/controller-gen@v0.8.0 object crd:crdVersions=v1 output:crd:artifacts:config=../config/crd/ paths=\"./...\"\n18: \n","filename":"experiments/composite/api/generate.go","matching_line":"//go:generate go run sigs.k8s.io/controller-tools/cmd/controller-gen@v0.8.0 object crd:crdVersions=v1 output:crd:artifacts:config=../config/crd/ paths=\"./...\""},{"context":"22: \n23: // Note: The functions below can be used in Polling because they are called on\n24: // paths holding fields that should absolutely be of the specified type. If not,\n25: // there is a fundamental error in which case we can exit the test immediately\n26: // instead of telling Poll to err.\n","filename":"experiments/compositions/composition/tests/testclient/unstructured.go","matching_line":"// paths holding fields that should absolutely be of the specified type. If not,"},{"context":"34: // The value of path / prefix should match whatever the API defines as its\n35: // operations endpoint, which is often most conveniently determined by looking\n36: // at the API documentation, or by seeing what paths clients request.\n37: func (s *Operations) RegisterOperationsPath(path string) func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n38: \treturn func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n","filename":"mockgcp/common/operations/http.go","matching_line":"// at the API documentation, or by seeing what paths clients request."},{"context":"190: \t// Fix our mockgcp hack:\n191: \t// The protobuf libraries get upset if we have two proto message types\n192: \t// with the same proto path, but different go paths.\n193: \t// The go client SDK for GCP uses the protos for some services,\n194: \t// so we need to \"get out of the way\" to avoid conflicts.\n","filename":"mockgcp/common/operations/operations.go","matching_line":"\t// with the same proto path, but different go paths."},{"context":"1093: \tunknownFields protoimpl.UnknownFields\n1094: \n1095: \t// Response does not include the possible roles of a member since the behavior of this rpc is not all-or-nothing unlike the other rpcs. So, it may not be possible to list all the roles definitively, due to possible lack of authorization in some of the paths.\n1096: \tHasMembership *bool `protobuf:\"varint,1,opt,name=has_membership,json=hasMembership\" json:\"has_membership,omitempty\"`\n1097: }\n","filename":"mockgcp/generated/google/apps/cloudidentity/groups/v1beta1/service.pb.go","matching_line":"\t// Response does not include the possible roles of a member since the behavior of this rpc is not all-or-nothing unlike the other rpcs. So, it may not be possible to list all the roles definitively, due to possible lack of authorization in some of the paths."},{"context":"1474: \t// Retrieves a `Membership`.\n1475: \tGetGroupsMembership(ctx context.Context, in *GetGroupsMembershipRequest, opts ...grpc.CallOption) (*Membership, error)\n1476: \t// Get a membership graph of just a member or both a member and a group. **Note:** This feature is only available to Google Workspace Enterprise Standard, Enterprise Plus, and Enterprise for Education; and Cloud Identity Premium accounts. Given a member, the response will contain all membership paths from the member. Given both a group and a member, the response will contain all membership paths between the group and the member.\n1477: \tGetMembershipGraphGroupsMembership(ctx context.Context, in *GetMembershipGraphGroupsMembershipRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)\n1478: \t// Lists the `Membership`s within a `Group`.\n","filename":"mockgcp/generated/google/apps/cloudidentity/groups/v1beta1/service_grpc.pb.go","matching_line":"\t// Get a membership graph of just a member or both a member and a group. **Note:** This feature is only available to Google Workspace Enterprise Standard, Enterprise Plus, and Enterprise for Education; and Cloud Identity Premium accounts. Given a member, the response will contain all membership paths from the member. Given both a group and a member, the response will contain all membership paths between the group and the member."},{"context":"784: \t// All of the files that are exported in this export operation. For custom\n785: \t// code training export, only three (training, validation and test)\n786: \t// Cloud Storage paths in wildcard format are populated\n787: \t// (for example, gs://.../training-*).\n788: \tExportedFiles []string `protobuf:\"bytes,1,rep,name=exported_files,json=exportedFiles,proto3\" json:\"exported_files,omitempty\"`\n","filename":"mockgcp/generated/mockgcp/cloud/aiplatform/v1beta1/dataset_service.pb.go","matching_line":"\t// Cloud Storage paths in wildcard format are populated"},{"context":"344: \t// Estimate your costs before enabling this option.\n345: \tEnableAccessLogging bool `protobuf:\"varint,13,opt,name=enable_access_logging,json=enableAccessLogging,proto3\" json:\"enable_access_logging,omitempty\"`\n346: \t// Output only. Provide paths for users to send predict/explain/health\n347: \t// requests directly to the deployed model services running on Cloud via\n348: \t// private services access. This field is populated if\n","filename":"mockgcp/generated/mockgcp/cloud/aiplatform/v1beta1/endpoint.pb.go","matching_line":"\t// Output only. Provide paths for users to send predict/explain/health"},{"context":"1581: \tunknownFields protoimpl.UnknownFields\n1582: \n1583: \t// Comma-separated list of API resources to be bundled in the API product. By default, the resource paths are mapped from the `proxy.pathsuffix` variable. The proxy path suffix is defined as the URI fragment following the ProxyEndpoint base path. For example, if the `apiResources` element is defined to be `/forecastrss` and the base path defined for the API proxy is `/weather`, then only requests to `/weather/forecastrss` are permitted by the API product. You can select a specific path, or you can select all subpaths with the following wildcard: - `/**`: Indicates that all sub-URIs are included. - `/*` : Indicates that only URIs one level down are included. By default, / supports the same resources as /** as well as the base path defined by the API proxy. For example, if the base path of the API proxy is `/v1/weatherapikey`, then the API product supports requests to `/v1/weatherapikey` and to any sub-URIs, such as `/v1/weatherapikey/forecastrss`, `/v1/weatherapikey/region/CA`, and so on. For more information, see Managing API products.\n1584: \tApiResources []string `protobuf:\"bytes,1,rep,name=api_resources,json=apiResources,proto3\" json:\"api_resources,omitempty\"`\n1585: \t// Flag that specifies how API keys are approved to access the APIs defined by the API product. If set to `manual`, the consumer key is generated and returned in \"pending\" state. In this case, the API keys won't work until they have been explicitly approved. If set to `auto`, the consumer key is generated and returned in \"approved\" state and can be used immediately. **Note:** Typically, `auto` is used to provide access to free or trial API products that provide limited quota or capabilities.\n","filename":"mockgcp/generated/mockgcp/cloud/apigee/v1/service.pb.go","matching_line":"\t// Comma-separated list of API resources to be bundled in the API product. By default, the resource paths are mapped from the `proxy.pathsuffix` variable. The proxy path suffix is defined as the URI fragment following the ProxyEndpoint base path. For example, if the `apiResources` element is defined to be `/forecastrss` and the base path defined for the API proxy is `/weather`, then only requests to `/weather/forecastrss` are permitted by the API product. You can select a specific path, or you can select all subpaths with the following wildcard: - `/**`: Indicates that all sub-URIs are included. - `/*` : Indicates that only URIs one level down are included. By default, / supports the same resources as /** as well as the base path defined by the API proxy. For example, if the base path of the API proxy is `/v1/weatherapikey`, then the API product supports requests to `/v1/weatherapikey` and to any sub-URIs, such as `/v1/weatherapikey/forecastrss`, `/v1/weatherapikey/region/CA`, and so on. For more information, see Managing API products."},{"context":"14266: \t// REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them.\n14267: \tPolicy *Policy `protobuf:\"bytes,1,opt,name=policy\" json:\"policy,omitempty\"`\n14268: \t// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: \"bindings, etag\"`\n14269: \tUpdateMask *string `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask\" json:\"update_mask,omitempty\"`\n14270: }\n","filename":"mockgcp/generated/mockgcp/cloud/bigquery/v2/api.pb.go","matching_line":"\t// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: \"bindings, etag\"`"},{"context":"683: \n684: type TrustConfig_IntermediateCA_PemCertificate struct {\n685: \t// PEM intermediate certificate used for building up paths\n686: \t// for validation.\n687: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/certificatemanager/v1/trust_config.pb.go","matching_line":"\t// PEM intermediate certificate used for building up paths"},{"context":"101958: \t// The body resource for this request\n101959: \tNetworkEdgeSecurityServiceResource *NetworkEdgeSecurityService `protobuf:\"bytes,477548966,opt,name=network_edge_security_service_resource,json=networkEdgeSecurityServiceResource,proto3\" json:\"network_edge_security_service_resource,omitempty\"`\n101960: \tPaths                              *string                     `protobuf:\"bytes,106438894,opt,name=paths,proto3,oneof\" json:\"paths,omitempty\"`\n101961: \t// Project ID for this request.\n101962: \tProject string `protobuf:\"bytes,227560217,opt,name=project,proto3\" json:\"project,omitempty\"`\n","filename":"mockgcp/generated/mockgcp/cloud/compute/v1/compute.pb.go","matching_line":"\tPaths                              *string                     `protobuf:\"bytes,106438894,opt,name=paths,proto3,oneof\" json:\"paths,omitempty\"`"},{"context":"1145: \t// root. If left unset, the root is used.\n1146: \tPath string `protobuf:\"bytes,3,opt,name=path,proto3\" json:\"path,omitempty\"`\n1147: \t// Optional. Maximum number of paths to return. The server may return fewer\n1148: \t// items than requested. If unspecified, the server will pick an appropriate\n1149: \t// default.\n","filename":"mockgcp/generated/mockgcp/cloud/dataform/v1beta1/dataform.pb.go","matching_line":"\t// Optional. Maximum number of paths to return. The server may return fewer"},{"context":"1215: \n1216: \t// Mask of fields to update.  At least one path must be supplied in this\n1217: \t// field.  The elements of the repeated paths field may only include these\n1218: \t// fields:\n1219: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/filestore/v1/cloud_filestore_service.pb.go","matching_line":"\t// field.  The elements of the repeated paths field may only include these"},{"context":"916: \t//\n917: \t// To refer to a specific commit:\n918: \t// `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`\n919: \t// To refer to a moveable alias (branch):\n920: \t// `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`\n","filename":"mockgcp/generated/mockgcp/cloud/functions/v1/functions.pb.go","matching_line":"\t// `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`"},{"context":"404: \tValidateOnly bool `protobuf:\"varint,2,opt,name=validate_only,json=validateOnly,proto3\" json:\"validate_only,omitempty\"`\n405: \t// Required. Mask of fields to update. At least one path must be supplied in\n406: \t// this field. The elements of the repeated paths field can only include these\n407: \t// fields from\n408: \t// [AttachedCluster][mockgcp.cloud.gkemulticloud.v1.AttachedCluster]:\n","filename":"mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/attached_service.pb.go","matching_line":"\t// this field. The elements of the repeated paths field can only include these"},{"context":"144: \tValidateOnly bool `protobuf:\"varint,2,opt,name=validate_only,json=validateOnly,proto3\" json:\"validate_only,omitempty\"`\n145: \t// Required. Mask of fields to update. At least one path must be supplied in\n146: \t// this field. The elements of the repeated paths field can only include these\n147: \t// fields from [AwsCluster][mockgcp.cloud.gkemulticloud.v1.AwsCluster]:\n148: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/aws_service.pb.go","matching_line":"\t// this field. The elements of the repeated paths field can only include these"},{"context":"144: \tValidateOnly bool `protobuf:\"varint,2,opt,name=validate_only,json=validateOnly,proto3\" json:\"validate_only,omitempty\"`\n145: \t// Required. Mask of fields to update. At least one path must be supplied in\n146: \t// this field. The elements of the repeated paths field can only include these\n147: \t// fields from [AzureCluster][mockgcp.cloud.gkemulticloud.v1.AzureCluster]:\n148: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/azure_service.pb.go","matching_line":"\t// this field. The elements of the repeated paths field can only include these"},{"context":"982: \t// REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them.\n983: \tPolicy *Policy `protobuf:\"bytes,1,opt,name=policy\" json:\"policy,omitempty\"`\n984: \t// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: \"bindings, etag\"`\n985: \tUpdateMask *string `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask\" json:\"update_mask,omitempty\"`\n986: }\n","filename":"mockgcp/generated/mockgcp/cloud/ids/v1/service.pb.go","matching_line":"\t// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: \"bindings, etag\"`"},{"context":"3824: \t// Required. ProducerInstanceLocation is used to specify which authorization mechanism to use to determine which projects the Producer instance can be within.\n3825: \tProducerInstanceLocation string `protobuf:\"bytes,3,opt,name=producer_instance_location,json=producerInstanceLocation,proto3\" json:\"producer_instance_location,omitempty\"`\n3826: \t// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.\n3827: \tSubnetworks []string `protobuf:\"bytes,4,rep,name=subnetworks,proto3\" json:\"subnetworks,omitempty\"`\n3828: }\n","filename":"mockgcp/generated/mockgcp/cloud/networkconnectivity/v1/networkconnectivity.pb.go","matching_line":"\t// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}."},{"context":"101: \t// Will only match the exact value provided.\n102: \tGrpcRoute_HeaderMatch_EXACT GrpcRoute_HeaderMatch_Type = 1\n103: \t// Will match paths conforming to the prefix specified by value. RE2\n104: \t// syntax is supported.\n105: \tGrpcRoute_HeaderMatch_REGULAR_EXPRESSION GrpcRoute_HeaderMatch_Type = 2\n","filename":"mockgcp/generated/mockgcp/cloud/networkservices/v1/grpc_route.pb.go","matching_line":"\t// Will match paths conforming to the prefix specified by value. RE2"},{"context":"1383: \t// if, it is in the mask. Any immutable fields set in the mask are ignored by\n1384: \t// the server. Repeated fields and map fields are only allowed in the last\n1385: \t// position of a `paths` string and overwrite the existing values. Hence an\n1386: \t// update to a repeated field or a map should contain the entire list of\n1387: \t// values. The fields specified in the update_mask are relative to the\n","filename":"mockgcp/generated/mockgcp/cloud/privilegedaccessmanager/v1/privilegedaccessmanager.pb.go","matching_line":"\t// position of a `paths` string and overwrite the existing values. Hence an"},{"context":"754: \n755: \t// Required. Mask of fields to update. At least one path must be supplied in\n756: \t// this field. The elements of the repeated paths field may only include these\n757: \t// fields from [Cluster][mockgcp.cloud.redis.cluster.v1.Cluster]:\n758: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/redis/cluster/v1/cloud_redis_cluster.pb.go","matching_line":"\t// this field. The elements of the repeated paths field may only include these"},{"context":"1806: \n1807: \t// Required. Mask of fields to update. At least one path must be supplied in\n1808: \t// this field. The elements of the repeated paths field may only include these\n1809: \t// fields from [Instance][mockgcp.cloud.redis.v1beta1.Instance]:\n1810: \t//\n","filename":"mockgcp/generated/mockgcp/cloud/redis/v1beta1/cloud_redis.pb.go","matching_line":"\t// this field. The elements of the repeated paths field may only include these"},{"context":"3556: \t// Specifies the resource type for the resource referred to by the field.\n3557: \tResourceType string `protobuf:\"bytes,2,opt,name=resource_type,json=resourceType,proto3\" json:\"resource_type,omitempty\"`\n3558: \t// Selects one or more request or response message fields to apply this `FieldPolicy`. When a `FieldPolicy` is used in proto annotation, the selector must be left as empty. The service config generator will automatically fill the correct value. When a `FieldPolicy` is used in service config, the selector must be a comma-separated string with valid request or response field paths, such as \"foo.bar\" or \"foo.bar,foo.baz\".\n3559: \tSelector string `protobuf:\"bytes,3,opt,name=selector,proto3\" json:\"selector,omitempty\"`\n3560: }\n","filename":"mockgcp/generated/mockgcp/cloud/servicenetworking/v1/servicenetworking.pb.go","matching_line":"\t// Selects one or more request or response message fields to apply this `FieldPolicy`. When a `FieldPolicy` is used in proto annotation, the selector must be left as empty. The service config generator will automatically fill the correct value. When a `FieldPolicy` is used in service config, the selector must be a comma-separated string with valid request or response field paths, such as \"foo.bar\" or \"foo.bar,foo.baz\"."},{"context":"192: \tunknownFields protoimpl.UnknownFields\n193: \n194: \t// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).\n195: \tUris []string `protobuf:\"bytes,1,rep,name=uris,proto3\" json:\"uris,omitempty\"`\n196: \t// Supports URI wildcards for matching multiple objects from a single URI.\n","filename":"mockgcp/generated/mockgcp/devtools/artifactregistry/v1/apt_artifact.pb.go","matching_line":"\t// Cloud Storage paths URI (e.g., gs://my_bucket//my_object)."},{"context":"172: \tunknownFields protoimpl.UnknownFields\n173: \n174: \t// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).\n175: \tUris []string `protobuf:\"bytes,1,rep,name=uris,proto3\" json:\"uris,omitempty\"`\n176: \t// Supports URI wildcards for matching multiple objects from a single URI.\n","filename":"mockgcp/generated/mockgcp/devtools/artifactregistry/v1/yum_artifact.pb.go","matching_line":"\t// Cloud Storage paths URI (e.g., gs://my_bucket//my_object)."},{"context":"2524: \t// Path at which to mount the volume.\n2525: \t//\n2526: \t// Paths must be absolute and cannot conflict with other volume paths on the\n2527: \t// same build step or with certain reserved volume paths.\n2528: \tPath string `protobuf:\"bytes,2,opt,name=path,proto3\" json:\"path,omitempty\"`\n","filename":"mockgcp/generated/mockgcp/devtools/cloudbuild/v1/cloudbuild.pb.go","matching_line":"\t// Paths must be absolute and cannot conflict with other volume paths on the"},{"context":"117: \t// represents any field.\n118: \t//\n119: \t// Field paths can be quoted using “ ` “ (backtick). The only character that\n120: \t// must be escaped within a quoted field path is the backtick character\n121: \t// itself, escaped using a backslash. Special characters in field paths that\n","filename":"mockgcp/generated/mockgcp/firestore/admin/v1/field.pb.go","matching_line":"\t// Field paths can be quoted using “ ` “ (backtick). The only character that"},{"context":"43: \t// [FirestoreAdmin.UpdateField][mockgcp.firestore.admin.v1.FirestoreAdmin.UpdateField]\n44: \t// should provide a field mask to avoid changing any configuration that the\n45: \t// caller isn't aware of. The field mask should be specified as: `{ paths:\n46: \t// \"index_config\" }`.\n47: \t//\n","filename":"mockgcp/generated/mockgcp/firestore/admin/v1/firestore_admin_grpc.pb.go","matching_line":"\t// caller isn't aware of. The field mask should be specified as: `{ paths:"},{"context":"297: \t// Required. The LogEntry field path to index.\n298: \t//\n299: \t// Note that some paths are automatically indexed, and other paths are not\n300: \t// eligible for indexing. See [indexing documentation](\n301: \t// https://cloud.google.com/logging/docs/view/advanced-queries#indexed-fields)\n","filename":"mockgcp/generated/mockgcp/logging/v2/logging_config.pb.go","matching_line":"\t// Note that some paths are automatically indexed, and other paths are not"},{"context":"73: \t// verified state, this method will fail (in other words, this may only be\n74: \t// used if the SendNotificationChannelVerificationCode and\n75: \t// VerifyNotificationChannel paths have already been used to put the given\n76: \t// channel into the verified state).\n77: \t//\n","filename":"mockgcp/generated/mockgcp/monitoring/v3/notification_service_grpc.pb.go","matching_line":"\t// VerifyNotificationChannel paths have already been used to put the given"},{"context":"331: \t// The given `name` specifies the resource to update.\n332: \tService *Service `protobuf:\"bytes,1,opt,name=service,proto3\" json:\"service,omitempty\"`\n333: \t// A set of field paths defining which fields to use for the update.\n334: \tUpdateMask *field_mask.FieldMask `protobuf:\"bytes,2,opt,name=update_mask,json=updateMask,proto3\" json:\"update_mask,omitempty\"`\n335: }\n","filename":"mockgcp/generated/mockgcp/monitoring/v3/service_service.pb.go","matching_line":"\t// A set of field paths defining which fields to use for the update."},{"context":"267: \t// source integrity was maintained in the build.\n268: \t//\n269: \t// The keys to this map are file paths used as build source and the values\n270: \t// contain the hash values for those files.\n271: \t//\n","filename":"mockgcp/generated/mockgrafeas/v1/provenance.pb.go","matching_line":"\t// The keys to this map are file paths used as build source and the values"},{"context":"216: \n217: \t// Required. A list of fields to be updated in this request.\n218: \tpaths := req.GetUpdateMask().GetPaths()\n219: \n220: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockalloydb/cluster.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"186: \n187: \t// Required. A list of fields to be updated in this request.\n188: \tpaths := req.GetUpdateMask().GetPaths()\n189: \n190: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockalloydb/instance.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"105: \n106: \t// Required. A list of fields to be updated in this request.\n107: \tpaths := req.GetUpdateMask()\n108: \tfieldMask, err := field_mask.New(obj, strings.Split(paths, \",\")...)\n109: \tif err != nil {\n","filename":"mockgcp/mockapigee/envgroup.go","matching_line":"\tpaths := req.GetUpdateMask()"},{"context":"126: \n127: \t// Required. A list of fields to be updated in this request.\n128: \tpaths := req.GetUpdateMask()\n129: \tfieldMask, err := fieldmaskpb.New(obj, strings.Split(paths, \",\")...)\n130: \tif err != nil {\n","filename":"mockgcp/mockapigee/instance.go","matching_line":"\tpaths := req.GetUpdateMask()"},{"context":"98: \n99: \t// Required. A list of fields to be updated in this request.\n100: \tpaths := req.GetUpdateMask().GetPaths()\n101: \n102: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockartifactregistry/repository.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"205: \n206: \tif err := fields.UpdateByFieldMask(obj, req.Connection, req.UpdateMask.Paths); err != nil {\n207: \t\treturn nil, fmt.Errorf(\"update field_mask.paths: %w\", err)\n208: \t}\n209: \tobj.LastModifiedTime = now.Unix()\n","filename":"mockgcp/mockbigqueryconnection/connection.go","matching_line":"\t\treturn nil, fmt.Errorf(\"update field_mask.paths: %w\", err)"},{"context":"148: \t}\n149: \n150: \tpaths := req.GetUpdateMask().GetPaths()\n151: \tfor _, path := range paths {\n152: \t\tswitch path {\n","filename":"mockgcp/mockbigquerydatatransfer/datatransfer.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"107: \n108: \tif err := fields.UpdateByFieldMask(obj, req.Reservation, req.UpdateMask.Paths); err != nil {\n109: \t\treturn nil, fmt.Errorf(\"update field_mask.paths: %w\", err)\n110: \t}\n111: \n","filename":"mockgcp/mockbigqueryreservation/reservation.go","matching_line":"\t\treturn nil, fmt.Errorf(\"update field_mask.paths: %w\", err)"},{"context":"94: \n95: \t// Required. The update mask applies to the resource.\n96: \tpaths := req.GetUpdateMask().GetPaths()\n97: \tif len(paths) == 0 {\n98: \t\tklog.Warningf(\"update_mask was not provided in request, should be required\")\n","filename":"mockgcp/mockcertificatemanager/certificate.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"94: \n95: \t// Required. The update mask applies to the resource.\n96: \tpaths := req.GetUpdateMask().GetPaths()\n97: \tif len(paths) == 0 {\n98: \t\tklog.Warningf(\"update_mask was not provided in request, should be required\")\n","filename":"mockgcp/mockcertificatemanager/certificatemap.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"94: \n95: \t// Required. The update mask applies to the resource.\n96: \tpaths := req.GetUpdateMask().GetPaths()\n97: \tif len(paths) == 0 {\n98: \t\tklog.Warningf(\"update_mask was not provided in request, should be required\")\n","filename":"mockgcp/mockcertificatemanager/certificatemapentry.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"102: \n103: \t// Required. The update mask applies to the resource.\n104: \tpaths := req.GetUpdateMask().GetPaths()\n105: \tif len(paths) == 0 {\n106: \t\tklog.Warningf(\"update_mask was not provided in request, should be required\")\n","filename":"mockgcp/mockcertificatemanager/dnsauthorization.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"81: \n82: \t// Required. The update mask applies to the resource.\n83: \tpaths := req.GetUpdateMask().GetPaths()\n84: \tif len(paths) == 0 {\n85: \t\tklog.Warningf(\"update_mask was not provided in request, should be required\")\n","filename":"mockgcp/mockcloudfunctions/v1.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"133: \t}\n134: \n135: \tpaths := strings.Split(request.GetUpdateMask(), \",\")\n136: \tfor _, path := range paths {\n137: \t\tswitch path {\n","filename":"mockgcp/mockcloudids/endpoint.go","matching_line":"\tpaths := strings.Split(request.GetUpdateMask(), \",\")"},{"context":"96: \n97: \t// Required. A list of fields to be updated in this request.\n98: \tpaths := req.GetUpdateMask().GetPaths()\n99: \n100: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockcontaineranalysis/note.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"98: \t}\n99: \n100: \tpaths := req.GetUpdateMask().GetPaths()\n101: \tif len(paths) == 0 {\n102: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask must be provided\")\n","filename":"mockgcp/mockdiscoveryengine/datastore.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"141: \t}\n142: \n143: \tpaths := req.GetUpdateMask().GetPaths()\n144: \tif len(paths) == 0 {\n145: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask must be provided\")\n","filename":"mockgcp/mockfilestore/instance.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"106: \tobj.UpdateTime = now\n107: \t// Required. A list of fields to be updated in this request.\n108: \tpaths := req.GetUpdateMask().GetPaths()\n109: \n110: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockgkehub/gkehubfeature.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"106: \tnow := timestamppb.Now()\n107: \t// Required. A list of fields to be updated in this request.\n108: \tpaths := req.GetUpdateMask().GetPaths()\n109: \n110: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockgkehub/gkehubmembership.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"122: \t}\n123: \t// Mask of fields to update. At least one path must be supplied in\n124: \t// this field. The elements of the repeated paths field can only include these\n125: \t// fields from\n126: \t// [AttachedCluster][mockgcp.cloud.gkemulticloud.v1.AttachedCluster]:\n","filename":"mockgcp/mockgkemulticloud/attachedcluster.go","matching_line":"\t// this field. The elements of the repeated paths field can only include these"},{"context":"164: \t// You can patch only the `display_name` and `description` fields.\n165: \t// You must use the `update_mask` field to specify which of these fields you want to patch.\n166: \tpaths := req.GetUpdateMask().GetPaths()\n167: \tfor _, path := range paths {\n168: \t\tswitch path {\n","filename":"mockgcp/mockiam/serviceaccounts.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"149: \n150: \t// Required. The update mask applies to the resource.\n151: \tpaths := req.GetUpdateMask().GetPaths()\n152: \tif len(paths) == 0 {\n153: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask is required\")\n","filename":"mockgcp/mocklogging/logbucket.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"99: \tupdated := proto.Clone(existing).(*pb.LogSink)\n100: \n101: \tpaths := req.GetUpdateMask().GetPaths()\n102: \tif len(paths) == 0 {\n103: \t\t// Optional, but we require it in our mock.\n","filename":"mockgcp/mocklogging/logsink.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"85: \n86: \t// Required. The update mask applies to the resource.\n87: \tpaths := req.GetUpdateMask().GetPaths()\n88: \tif len(paths) == 0 {\n89: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask is required by mock\")\n","filename":"mockgcp/mocklogging/logview.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"113: \t\treturn nil, err\n114: \t}\n115: \tpaths := req.GetUpdateMask().GetPaths()\n116: \tif len(paths) == 0 {\n117: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask must be provided\")\n","filename":"mockgcp/mockmanagedkafka/cluster.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"140: \n141: \tif req.GetUpdateMask() != \"\" {\n142: \t\tpaths := strings.Split(req.GetUpdateMask(), \",\")\n143: \n144: \t\tpatch := req.GetProjectsLocationsServiceConnectionPolicy()\n","filename":"mockgcp/mocknetworkconnectivity/serviceconnectionpolicies.go","matching_line":"\t\tpaths := strings.Split(req.GetUpdateMask(), \",\")"},{"context":"88: \t// the full request. A field will be overwritten if it is in the mask. If the\n89: \t// user does not provide a mask then all fields will be overwritten.\n90: \tpaths := req.GetUpdateMask().GetPaths()\n91: \t// TODO: Some sort of helper for fieldmask?\n92: \tfor _, path := range paths {\n","filename":"mockgcp/mocknetworkservices/networkservices.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"120: \n121: \t// Required. A list of fields to be updated in this request.\n122: \tpaths := req.GetUpdateMask().GetPaths()\n123: \n124: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockprivateca/capool.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"96: \n97: \t// Required. A list of fields to be updated in this request.\n98: \tpaths := req.GetUpdateMask().GetPaths()\n99: \n100: \tfor _, path := range paths {\n","filename":"mockgcp/mockprivilegedaccessmanager/entitlement.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"99: \n100: \t// Required. The update mask applies to the resource.\n101: \tpaths := req.GetUpdateMask().GetPaths()\n102: \tif len(paths) == 0 {\n103: \t\t// Documented as required, but not passed by terraform...\n","filename":"mockgcp/mockpubsub/subscription.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"102: \n103: \t// Required. The update mask applies to the resource.\n104: \tpaths := req.GetUpdateMask().GetPaths()\n105: \tif len(paths) == 0 {\n106: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask is required\")\n","filename":"mockgcp/mockpubsub/topic.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"83: \n84: \t// Required. A list of fields to be updated in this request.\n85: \tpaths := req.GetUpdateMask().GetPaths()\n86: \n87: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockpubsublite/reservation.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"82: \n83: \t// Required. A list of fields to be updated in this request.\n84: \tpaths := req.GetUpdateMask().GetPaths()\n85: \n86: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockpubsublite/subscription.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"82: \n83: \t// Required. A list of fields to be updated in this request.\n84: \tpaths := req.GetUpdateMask().GetPaths()\n85: \n86: \t// TODO: Some sort of helper for fieldmask?\n","filename":"mockgcp/mockpubsublite/topic.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"219: \n220: \t// Required. Mask of fields to update. At least one path must be supplied in\n221: \t// this field. The elements of the repeated paths field may only include these\n222: \t// fields from [Cluster][mockgcp.cloud.redis.cluster.v1.Cluster]:\n223: \t//\n","filename":"mockgcp/mockredis/cluster.go","matching_line":"\t// this field. The elements of the repeated paths field may only include these"},{"context":"178: \n179: \t// Required. Mask of fields to update. At least one path must be supplied in\n180: \t// this field. The elements of the repeated paths field may only include these\n181: \t// fields from Instance:\n182: \t//\n","filename":"mockgcp/mockredis/instance.go","matching_line":"\t// this field. The elements of the repeated paths field may only include these"},{"context":"118: \t// Only the `display_name` field can be changed.\n119: \n120: \tpaths := req.GetUpdateMask().GetPaths()\n121: \tfor _, path := range paths {\n122: \t\tswitch path {\n","filename":"mockgcp/mockresourcemanager/folders.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"177: \n178: // \t// Only the `display_name` and `labels` fields can be change.\n179: // \tpaths := req.GetUpdateMask().GetPaths()\n180: // \tif len(paths) == 0 {\n181: // \t\tif len(req.GetProject().GetLabels()) != 0 {\n","filename":"mockgcp/mockresourcemanager/projects_internal.go","matching_line":"// \tpaths := req.GetUpdateMask().GetPaths()"},{"context":"96: func (s *ProjectsV3) UpdateProject(ctx context.Context, req *pb.UpdateProjectRequest) (*longrunningpb.Operation, error) {\n97: \tmutator := func(obj *pb.Project) error { // Only the `display_name` and `labels` fields can be change.\n98: \t\tpaths := req.GetUpdateMask().GetPaths()\n99: \t\tif len(paths) == 0 {\n100: \t\t\tif len(req.GetProject().GetLabels()) != 0 {\n","filename":"mockgcp/mockresourcemanager/projectsv3.go","matching_line":"\t\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"133: \t// `etag`. If omitted entirely, both `description` and `etag` are assumed to\n134: \t// be significant.\n135: \tpaths := req.GetUpdateMask().GetPaths()\n136: \tfor _, path := range paths {\n137: \t\tswitch path {\n","filename":"mockgcp/mockresourcemanager/tagkeys.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"148: \t// We should verify that this is part of on of our projects, but ... it's a mock\n149: \n150: \tpaths := req.GetUpdateMask().GetPaths()\n151: \tfor _, path := range paths {\n152: \t\tswitch path {\n","filename":"mockgcp/mockresourcemanager/tagvalues.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"135: \n136: \t// Required. The update mask applies to the resource.\n137: \tpaths := req.GetUpdateMask().GetPaths()\n138: \tif len(paths) == 0 {\n139: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask is required\")\n","filename":"mockgcp/mocksecretmanager/secrets.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"143: \n144: \t// Required. The update mask applies to the resource.\n145: \tpaths := req.GetUpdateMask().GetPaths()\n146: \tif len(paths) == 0 {\n147: \t\treturn nil, status.Errorf(codes.InvalidArgument, \"update_mask must be provided\")\n","filename":"mockgcp/mockworkflows/workflow.go","matching_line":"\tpaths := req.GetUpdateMask().GetPaths()"},{"context":"25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s\"\n26: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest\"\n27: \ttestpaths \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n28: \n29: \t\"github.com/google/go-cmp/cmp\"\n","filename":"operator/pkg/manifest/repo_test.go","matching_line":"\ttestpaths \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"33: \tcorev1beta1 \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/apis/core/v1beta1\"\n34: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/controllers\"\n35: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n36: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/kccmanager/nocache\"\n37: )\n","filename":"operator/pkg/test/main/testmain.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"13: // limitations under the License.\n14: \n15: package paths\n16: \n17: import (\n","filename":"operator/pkg/test/util/paths/paths.go","matching_line":"package paths"},{"context":"25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s\"\n26: \tcnrmmanifest \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest\"\n27: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n28: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/scripts/utils\"\n29: \n","filename":"operator/scripts/copy-dependency-manifests/main.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"39: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s\"\n40: \tcnrmmanifest \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest\"\n41: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n42: )\n43: \n","filename":"operator/scripts/generate-image-configmap/main.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"30: \n31: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s\"\n32: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n33: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/scripts/utils\"\n34: \t\"github.com/blang/semver/v4\"\n","filename":"operator/scripts/update-kcc-manifest/main.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"932: \tyamlPaths, err := getYAMLFilesInDir(repoYAMLDir)\n933: \tif err != nil {\n934: \t\treturn \"\", \"\", fmt.Errorf(\"error getting paths to YAML files in ArtifactRegistryRepository sample directory '%v': %w\", repoYAMLDir, err)\n935: \t}\n936: \tfor _, yamlPath := range yamlPaths {\n","filename":"operator/tests/e2e/e2e_test.go","matching_line":"\t\treturn \"\", \"\", fmt.Errorf(\"error getting paths to YAML files in ArtifactRegistryRepository sample directory '%v': %w\", repoYAMLDir, err)"},{"context":"199: \t// `status.observedState` in the CRD, and in the CR after a successful\n200: \t// reconciliation.\n201: \t// The fields should be snake case paths in TF. For example,\n202: \t// `master_auth.client_certificate`.\n203: \tObservedFields *[]string `json:\"observedFields,omitempty\"`\n","filename":"pkg/apis/core/v1alpha1/servicemapping_types.go","matching_line":"\t// The fields should be snake case paths in TF. For example,"},{"context":"232: // []interface{} and the same is true for each sub-key\n233: //\n234: // The reason why the map contains slices in the middle of paths is a terraform oddity where often times there can be a\n235: // list of size 1 for various reasons\n236: func getValueInSliceAwareNestedMap(object interface{}, path []string) (interface{}, bool, error) {\n","filename":"pkg/cli/gcpclient/resolve_apiserver_dependencies_test.go","matching_line":"// The reason why the map contains slices in the middle of paths is a terraform oddity where often times there can be a"},{"context":"423: \tRequireMatchingFile *bool `json:\"requireMatchingFile,omitempty\"`\n424: \n425: \t/* Regular expression that matches the file paths for all files that should be referenced by this handler. */\n426: \t// +optional\n427: \tUploadPathRegex *string `json:\"uploadPathRegex,omitempty\"`\n","filename":"pkg/clients/generated/apis/appengine/v1alpha1/appengineflexibleappversion_types.go","matching_line":"\t/* Regular expression that matches the file paths for all files that should be referenced by this handler. */"},{"context":"206: \tRequireMatchingFile *bool `json:\"requireMatchingFile,omitempty\"`\n207: \n208: \t/* Regular expression that matches the file paths for all files that should be referenced by this handler. */\n209: \t// +optional\n210: \tUploadPathRegex *string `json:\"uploadPathRegex,omitempty\"`\n","filename":"pkg/clients/generated/apis/appengine/v1alpha1/appenginestandardappversion_types.go","matching_line":"\t/* Regular expression that matches the file paths for all files that should be referenced by this handler. */"},{"context":"56: \t/* A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.\n57: \n58: \tFiles in the workspace matching specified paths globs will be uploaded to the\n59: \tCloud Storage location using the builder service account's credentials.\n60: \n","filename":"pkg/clients/generated/apis/cloudbuild/v1beta1/cloudbuildtrigger_types.go","matching_line":"\tFiles in the workspace matching specified paths globs will be uploaded to the"},{"context":"81: \n82: \tTo refer to a specific commit:\n83: \t`https://source.developers.google.com/projects/* /repos/* /revisions/* /paths/*`\n84: \tTo refer to a moveable alias (branch):\n85: \t`https://source.developers.google.com/projects/* /repos/* /moveable-aliases/* /paths/*`\n","filename":"pkg/clients/generated/apis/cloudfunctions/v1beta1/cloudfunctionsfunction_types.go","matching_line":"\t`https://source.developers.google.com/projects/* /repos/* /revisions/* /paths/*`"},{"context":"466: \tare specified does not matter. Matches are always done on the longest-path-first\n467: \tbasis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*\n468: \tirrespective of the order in which those paths appear in this list. Within a\n469: \tgiven pathMatcher, only one of pathRules or routeRules must be set. */\n470: \t// +optional\n","filename":"pkg/clients/generated/apis/compute/v1beta1/computeurlmap_types.go","matching_line":"\tirrespective of the order in which those paths appear in this list. Within a"},{"context":"444: \tDescription *string `json:\"description,omitempty\"`\n445: \n446: \t/* Immutable. Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args */\n447: \tFields []string `json:\"fields\"`\n448: \n","filename":"pkg/clients/generated/apis/dataproc/v1beta1/dataprocworkflowtemplate_types.go","matching_line":"\t/* Immutable. Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args */"},{"context":"452: \tBucketRef v1alpha1.ResourceRef `json:\"bucketRef\"`\n453: \n454: \t/* A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub. */\n455: \t// +optional\n456: \tExcludeRegex []string `json:\"excludeRegex,omitempty\"`\n","filename":"pkg/clients/generated/apis/dlp/v1beta1/dlpjobtrigger_types.go","matching_line":"\t/* A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub. */"},{"context":"45: \tProducerInstanceLocation *string `json:\"producerInstanceLocation,omitempty\"`\n46: \n47: \t/* The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}. */\n48: \t// +optional\n49: \tSubnetworkRefs []v1alpha1.ResourceRef `json:\"subnetworkRefs,omitempty\"`\n","filename":"pkg/clients/generated/apis/networkconnectivity/v1alpha1/networkconnectivityserviceconnectionpolicy_types.go","matching_line":"\t/* The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}. */"},{"context":"45: \n46: \t* 'PathGlobs'\n47: \t* 'paths'\n48: \t* 'acl'\n49: \t* 'URLPrefix'\n","filename":"pkg/clients/generated/apis/networkservices/v1alpha1/networkservicesedgecacheservice_types.go","matching_line":"\t* 'paths'"},{"context":"279: \t\treturn mapCtx.Err()\n280: \t}\n281: \tpaths, err := common.CompareProtoMessage(connection, a.actual, common.BasicDiff)\n282: \tif err != nil {\n283: \t\treturn err\n","filename":"pkg/controller/direct/bigqueryconnection/connection_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(connection, a.actual, common.BasicDiff)"},{"context":"269: \twp.Etag = a.actual.Etag\n270: \n271: \tpaths, err := common.CompareProtoMessage(wp, a.actual, common.BasicDiff)\n272: \tif err != nil {\n273: \t\treturn err\n","filename":"pkg/controller/direct/cloudbuild/workerpool_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(wp, a.actual, common.BasicDiff)"},{"context":"137: \t}\n138: \n139: \tpaths := calculateUpdateMask(desiredPb, a.actual)\n140: \tif len(paths) == 0 {\n141: \t\tlog.V(2).Info(\"no field needs update\", \"name\", a.id.String())\n","filename":"pkg/controller/direct/iap/iapsettings_controller.go","matching_line":"\tpaths := calculateUpdateMask(desiredPb, a.actual)"},{"context":"116: }\n117: \n118: // ListFieldDiffsForUnstructured returns a list of field paths where the values differ, for two unstructured objects.\n119: func ListFieldDiffsForUnstructured(l, r *unstructured.Unstructured) ([]string, error) {\n120: \to := \u0026objectDiffWalker{}\n","filename":"pkg/controller/direct/logging/diffs.go","matching_line":"// ListFieldDiffsForUnstructured returns a list of field paths where the values differ, for two unstructured objects."},{"context":"290: \t\tif err != nil {\n291: \t\t\t// Don't return an error as we're only logging\n292: \t\t\tlog.Error(err, \"computing changed field paths (for logging)\")\n293: \t\t}\n294: \t\tlog.Info(\"updating logMetric\", \"diffs\", diffs)\n","filename":"pkg/controller/direct/logging/logmetric_controller.go","matching_line":"\t\t\tlog.Error(err, \"computing changed field paths (for logging)\")"},{"context":"185: \tdesiredPb.Name = a.id.String()\n186: \n187: \tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)\n188: \tif err != nil {\n189: \t\treturn err\n","filename":"pkg/controller/direct/managedkafka/cluster_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)"},{"context":"167: \tdesiredPb.Name = a.id.String()\n168: \n169: \tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)\n170: \tif err != nil {\n171: \t\treturn err\n","filename":"pkg/controller/direct/managedkafka/topic_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)"},{"context":"174: \n175: \tvar err error\n176: \tpaths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)\n177: \tif err != nil {\n178: \t\treturn err\n","filename":"pkg/controller/direct/migrationcenter/group_controller.go","matching_line":"\tpaths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)"},{"context":"47: \t\t)\n48: \n49: \t\t// Widgets are under a few paths\n50: \t\twidgetPaths := []string{\n51: \t\t\t\".grid_layout.widgets[]\",\n","filename":"pkg/controller/direct/monitoring/roundtrip_test.go","matching_line":"\t\t// Widgets are under a few paths"},{"context":"255: \tresource.Name = a.id.String()\n256: \tresource.Etag = a.actual.Etag\n257: \tpaths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)\n258: \tif err != nil {\n259: \t\treturn err\n","filename":"pkg/controller/direct/secretmanager/secret_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)"},{"context":"223: \tresource.Etag = a.actual.Etag\n224: \n225: \tpaths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)\n226: \tif err != nil {\n227: \t\treturn err\n","filename":"pkg/controller/direct/workstations/config_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)"},{"context":"204: \tdesiredPb.Etag = a.actual.Etag\n205: \n206: \tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)\n207: \tif err != nil {\n208: \t\treturn err\n","filename":"pkg/controller/direct/workstations/workstation_controller.go","matching_line":"\tpaths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)"},{"context":"31: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s\"\n32: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text\"\n33: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n34: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/slice\"\n35: \n","filename":"pkg/crd/crdgeneration/dcl2crdgeneration.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"22: \t\"strings\"\n23: \n24: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text\"\n26: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/repo\"\n","filename":"pkg/crd/crdloader/crdloader.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s\"\n26: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/label\"\n27: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n28: \n29: \tdclunstruct \"github.com/GoogleCloudPlatform/declarative-resource-client-library/unstructured\"\n","filename":"pkg/dcl/conversion/converter.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"21: \n22: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/dcl/constants\"\n23: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n24: \n25: \t\"github.com/nasa9084/go-openapi\"\n","filename":"pkg/dcl/extension/extension.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"16: \n17: import (\n18: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n19: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/slice\"\n20: )\n","filename":"pkg/dcl/fields.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"29: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader\"\n30: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util\"\n31: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n32: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/typeutil\"\n33: \n","filename":"pkg/dcl/kcclite/conversion.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"30: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader\"\n31: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util\"\n32: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n33: \n34: \tmmdcl \"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl\"\n","filename":"pkg/dcl/livestate/fetchlivestate.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"26: \n27: func MutableButUnreadableFieldsAnnotationFor(r *Resource) (string, error) {\n28: \tpaths, err := getMutableButUnreadablePaths(r)\n29: \tif err != nil {\n30: \t\treturn \"\", fmt.Errorf(\"error getting mutable-but-unreadable fields for resource: %w\", err)\n","filename":"pkg/dcl/mutableunreadable.go","matching_line":"\tpaths, err := getMutableButUnreadablePaths(r)"},{"context":"22: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s\"\n23: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util\"\n24: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n25: \n26: \t\"github.com/google/go-cmp/cmp\"\n","filename":"pkg/dcl/mutableunreadable_test.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text\"\n26: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util\"\n27: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n28: \n29: \t\"github.com/nasa9084/go-openapi\"\n","filename":"pkg/dcl/references.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"23: \n24: func MutableButUnreadableFieldsAnnotationFor(r *Resource) (string, error) {\n25: \tpaths := getMutableButUnreadablePaths(r)\n26: \treturn k8s.GenerateMutableButUnreadableFieldsAnnotation(\u0026r.Resource, paths)\n27: }\n","filename":"pkg/krmtotf/mutableunreadable.go","matching_line":"\tpaths := getMutableButUnreadablePaths(r)"},{"context":"582: }\n583: \n584: // validateAtMostOneFieldIsSetUnderSlice returns error if both field paths within the slice field are set\n585: func validateAtMostOneFieldIsSetUnderSlice(r *k8s.Resource, fieldPathUpToSlice, fieldPath1, fieldPath2 []string) error {\n586: \tsliceField, found, err := unstructured.NestedSlice(r.Spec, fieldPathUpToSlice...)\n","filename":"pkg/resourceoverrides/utils.go","matching_line":"// validateAtMostOneFieldIsSetUnderSlice returns error if both field paths within the slice field are set"},{"context":"53: \t\t\"datafusion\":              {\"datafusioninstance\"},\n54: \t\t\"dataproc\":                {\"dataproccluster\"},\n55: \t\t\"dlp\":                     {\"cloudstoragepathstoredinfotype\"},\n56: \t\t\"dns\":                     {\"dnsrecordset\"},\n57: \t\t\"edgecontainer\":           {\"edgecontainercluster\"},\n","filename":"pkg/test/constants/presubmitconstants.go","matching_line":"\t\t\"dlp\":                     {\"cloudstoragepathstoredinfotype\"},"},{"context":"21: \n22: \toperatorv1beta1 \"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/apis/core/v1beta1\"\n23: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\"\n24: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis\"\n25: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/test\"\n","filename":"pkg/test/environment/environment.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths\""},{"context":"26: )\n27: \n28: // IDEA: Load all the samples, and check that we have all the KRM paths covered\n29: \n30: func FillWithRandom(t *testing.T, randStream *rand.Rand, msg proto.Message) {\n","filename":"pkg/test/fuzz/generate.go","matching_line":"// IDEA: Load all the samples, and check that we have all the KRM paths covered"},{"context":"26: \t\tSkipUpdate: true,\n27: \t}\n28: \tresourceContextMap[\"cloudstoragepathstoredinfotype\"] = ResourceContext{\n29: \t\tResourceKind: \"DLPStoredInfoType\",\n30: \t\t// There is no update method for this resource.\n","filename":"pkg/test/resourcefixture/contexts/dlp_context.go","matching_line":"\tresourceContextMap[\"cloudstoragepathstoredinfotype\"] = ResourceContext{"},{"context":"13: // limitations under the License.\n14: \n15: package pathslice\n16: \n17: import \"strings\"\n","filename":"pkg/util/pathslice/pathslice.go","matching_line":"package pathslice"},{"context":"83: \n84: // Write does an atomic projection of the given payload into the writer's target\n85: // directory.  Input paths must not begin with '..'.\n86: //\n87: // The Write algorithm is:\n","filename":"pkg/webhook/cert/writer/atomic/atomic_writer.go","matching_line":"// directory.  Input paths must not begin with '..'."},{"context":"37: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader\"\n38: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text\"\n39: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\"\n40: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/typeutil\"\n41: \n","filename":"pkg/webhook/immutable_fields_validator.go","matching_line":"\t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice\""},{"context":"550: }\n551: \n552: // findLinksInEvent looks for link paths and feeds the values into replacement.ExtractIDsFromLinks\n553: func findLinksInEvent(t *testing.T, replacement *Replacements, event *test.LogEntry) {\n554: \tlinkPaths := sets.New(\n","filename":"tests/e2e/normalize.go","matching_line":"// findLinksInEvent looks for link paths and feeds the values into replacement.ExtractIDsFromLinks"},{"context":"453: // for a given test, allowing for recording of HTTP interactions.\n454: // Why this exists: schema.Provider.ConfigureFunc is called multiple times for a given test\n455: // ConfigureFunc on our provider creates a new HTTP client and sets base paths (config.go LoadAndValidate)\n456: // VCR requires a single HTTP client to handle all interactions so it can record and replay responses so\n457: // this caches HTTP clients per test by replacing ConfigureFunc\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/acctest/vcr_utils.go","matching_line":"// ConfigureFunc on our provider creates a new HTTP client and sets base paths (config.go LoadAndValidate)"},{"context":"50: \tUserProjectOverride        types.Bool\n51: \n52: \t// paths for client setup\n53: \tAccessApprovalBasePath           string\n54: \tAccessContextManagerBasePath     string\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go","matching_line":"\t// paths for client setup"},{"context":"17: \n18: // Methods to create new services from config\n19: // Some base paths below need the version and possibly more of the path\n20: // set on them. The client libraries are inconsistent about which values they need;\n21: // while most only want the host URL, some older ones also want the version and some\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_provider_clients.go","matching_line":"// Some base paths below need the version and possibly more of the path"},{"context":"639: \t\t\t\t\t\t\t\t\t\tType:        schema.TypeString,\n640: \t\t\t\t\t\t\t\t\t\tOptional:    true,\n641: \t\t\t\t\t\t\t\t\t\tDescription: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,\n642: \t\t\t\t\t\t\t\t\t},\n643: \t\t\t\t\t\t\t\t},\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/appengine/resource_app_engine_flexible_app_version.go","matching_line":"\t\t\t\t\t\t\t\t\t\tDescription: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,"},{"context":"329: \t\t\t\t\t\t\t\t\t\tType:        schema.TypeString,\n330: \t\t\t\t\t\t\t\t\t\tOptional:    true,\n331: \t\t\t\t\t\t\t\t\t\tDescription: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,\n332: \t\t\t\t\t\t\t\t\t},\n333: \t\t\t\t\t\t\t\t},\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/appengine/resource_app_engine_standard_app_version.go","matching_line":"\t\t\t\t\t\t\t\t\t\tDescription: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,"},{"context":"1429: \tkmsKeyName := v.(map[string]interface{})[\"kmsKeyName\"].(string)\n1430: \tre := regexp.MustCompile(`(projects/.*/locations/.*/keyRings/.*/cryptoKeys/.*)/cryptoKeyVersions/.*`)\n1431: \tpaths := re.FindStringSubmatch(kmsKeyName)\n1432: \n1433: \tif len(paths) \u003e 0 {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/bigquery/resource_bigquery_job.go","matching_line":"\tpaths := re.FindStringSubmatch(kmsKeyName)"},{"context":"2069: func flattenEncryptionConfiguration(ec *bigquery.EncryptionConfiguration) []map[string]interface{} {\n2070: \tre := regexp.MustCompile(`(projects/.*/locations/.*/keyRings/.*/cryptoKeys/.*)/cryptoKeyVersions/.*`)\n2071: \tpaths := re.FindStringSubmatch(ec.KmsKeyName)\n2072: \n2073: \tif len(paths) \u003e 0 {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/bigquery/resource_bigquery_table.go","matching_line":"\tpaths := re.FindStringSubmatch(ec.KmsKeyName)"},{"context":"89: \t\t\t\t\t\t\t\t\t\tType:     schema.TypeString,\n90: \t\t\t\t\t\t\t\t\t\tOptional: true,\n91: \t\t\t\t\t\t\t\t\t\tDescription: `PEM intermediate certificate used for building up paths for validation.\n92: Each certificate provided in PEM format may occupy up to 5kB.`,\n93: \t\t\t\t\t\t\t\t\t\tSensitive: true,\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/certificatemanager/resource_certificate_manager_trust_config.go","matching_line":"\t\t\t\t\t\t\t\t\t\tDescription: `PEM intermediate certificate used for building up paths for validation."},{"context":"374: \t\t\t\t\t\t\t\t\t\t\t\t\tDescription: `Path at which to mount the volume.\n375: \n376: Paths must be absolute and cannot conflict with other volume paths on\n377: the same build step or with certain reserved volume paths.`,\n378: \t\t\t\t\t\t\t\t\t\t\t\t},\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger.go","matching_line":"Paths must be absolute and cannot conflict with other volume paths on"},{"context":"154:       objects {\n155:         location = \"gs://bucket/path/to/somewhere/\"\n156:         paths = [\"path\"]\n157:       }\n158:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger_generated_test.go","matching_line":"        paths = [\"path\"]"},{"context":"267:       objects {\n268:         location = \"gs://bucket/path/to/somewhere/\"\n269:         paths = [\"path\"]\n270:       }\n271:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger_test.go","matching_line":"        paths = [\"path\"]"},{"context":"429: \t\t\t\t\t\t\tType:        schema.TypeString,\n430: \t\t\t\t\t\t\tRequired:    true,\n431: \t\t\t\t\t\t\tDescription: `The path within the container to mount the secret volume. For example, setting the mount_path as \"/etc/secrets\" would mount the secret value files under the \"/etc/secrets\" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: \"/etc/secrets\" Restricted mount paths: \"/cloudsql\", \"/dev/log\", \"/pod\", \"/proc\", \"/var/log\".`,\n432: \t\t\t\t\t\t},\n433: \t\t\t\t\t\t\"project_id\": {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudfunctions/resource_cloudfunctions_function.go","matching_line":"\t\t\t\t\t\t\tDescription: `The path within the container to mount the secret volume. For example, setting the mount_path as \"/etc/secrets\" would mount the secret value files under the \"/etc/secrets\" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: \"/etc/secrets\" Restricted mount paths: \"/cloudsql\", \"/dev/log\", \"/pod\", \"/proc\", \"/var/log\".`,"},{"context":"907:     // here. If this test is run outside of CI, you may need to create your own\n908:     // source repo.\n909:     url = \"https://source.developers.google.com/projects/%s/repos/cloudfunctions-test-do-not-delete/moveable-aliases/master/paths/\"\n910:   }\n911: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudfunctions/resource_cloudfunctions_function_test.go","matching_line":"    url = \"https://source.developers.google.com/projects/%s/repos/cloudfunctions-test-do-not-delete/moveable-aliases/master/paths/\""},{"context":"1820:   host_rule {\n1821:     hosts        = [\"mysite.com\"]\n1822:     path_matcher = \"allpaths\"\n1823:   }\n1824: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_backend_service_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"1239: \t\t}\n1240: \n1241: \t\turl, err := tpgresource.ReplaceVars(d, config, \"{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/disks/{{name}}?paths=provisionedIops\")\n1242: \t\tif err != nil {\n1243: \t\t\treturn err\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_disk.go","matching_line":"\t\turl, err := tpgresource.ReplaceVars(d, config, \"{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/disks/{{name}}?paths=provisionedIops\")"},{"context":"436:   host_rule {\n437:     hosts        = [\"mysite.com\"]\n438:     path_matcher = \"allpaths\"\n439:   }\n440: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_global_forwarding_rule_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"207:     name            = \"boop\"\n208:     path_rule {\n209:       paths   = [\"/*\"]\n210:       service = google_compute_backend_service.backend.self_link\n211:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_global_forwarding_rule_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"874: \n875: \tfor k, v := range expected {\n876: \t\t// source is the only self link, so compare by relpaths if source is being\n877: \t\t// compared\n878: \t\tif strings.HasSuffix(k, \"source\") {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_instance_migrate_test.go","matching_line":"\t\t// source is the only self link, so compare by relpaths if source is being"},{"context":"79:   host_rule {\n80:     hosts        = [\"sslcert.tf-test.club\"]\n81:     path_matcher = \"allpaths\"\n82:   }\n83: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_managed_ssl_certificate_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"198:   host_rule {\n199:     hosts        = [\"mysite.com\"]\n200:     path_matcher = \"allpaths\"\n201:   }\n202: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_ssl_certificate_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"71:   host_rule {\n72:     hosts        = [\"mysite.com\"]\n73:     path_matcher = \"allpaths\"\n74:   }\n75: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_http_proxy_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"78:     name            = \"boop\"\n79:     path_rule {\n80:       paths   = [\"/*\"]\n81:       service = google_compute_region_backend_service.foobar.self_link\n82:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_http_proxy_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"81:   host_rule {\n82:     hosts        = [\"mysite.com\"]\n83:     path_matcher = \"allpaths\"\n84:   }\n85: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_https_proxy_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"97:     name            = \"boop\"\n98:     path_rule {\n99:       paths   = [\"/*\"]\n100:       service = google_compute_region_backend_service.foobar1.self_link\n101:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_https_proxy_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"697: are specified does not matter. Matches are always done on the longest-path-first\n698: basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*\n699: irrespective of the order in which those paths appear in this list. Within a\n700: given pathMatcher, only one of pathRules or routeRules must be set.`,\n701: \t\t\t\t\t\t\tElem: \u0026schema.Resource{\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map.go","matching_line":"irrespective of the order in which those paths appear in this list. Within a"},{"context":"68:   host_rule {\n69:     hosts        = [\"mysite.com\"]\n70:     path_matcher = \"allpaths\"\n71:   }\n72: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"264: \n265:     path_rule {\n266:       paths   = [\"/*\"]\n267:       service = google_compute_region_backend_service.foobar.self_link\n268:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"1131: \t\t\t// add added projects to updateMask\n1132: \t\t\tif firstProject != true {\n1133: \t\t\t\tmaskId = fmt.Sprintf(\"%s%s\", \"\u0026paths=shareSettings.projectMap.\", original[\"project_id\"])\n1134: \t\t\t} else {\n1135: \t\t\t\tmaskId = fmt.Sprintf(\"%s%s\", \"?paths=shareSettings.projectMap.\", original[\"project_id\"])\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_reservation.go","matching_line":"\t\t\t\tmaskId = fmt.Sprintf(\"%s%s\", \"\u0026paths=shareSettings.projectMap.\", original[\"project_id\"])"},{"context":"192:   host_rule {\n193:     hosts        = [\"mysite.com\"]\n194:     path_matcher = \"allpaths\"\n195:   }\n196: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_ssl_certificate_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"70:   host_rule {\n71:     hosts        = [\"mysite.com\"]\n72:     path_matcher = \"allpaths\"\n73:   }\n74:   path_matcher {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_grpc_proxy_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"59:   host_rule {\n60:     hosts        = [\"mysite.com\"]\n61:     path_matcher = \"allpaths\"\n62:   }\n63:   path_matcher {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_grpc_proxy_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"69:   host_rule {\n70:     hosts        = [\"mysite.com\"]\n71:     path_matcher = \"allpaths\"\n72:   }\n73: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_http_proxy_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"104:     name            = \"boop\"\n105:     path_rule {\n106:       paths   = [\"/*\"]\n107:       service = google_compute_backend_service.foobar.self_link\n108:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_http_proxy_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"78:   host_rule {\n79:     hosts        = [\"mysite.com\"]\n80:     path_matcher = \"allpaths\"\n81:   }\n82: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_https_proxy_generated_test.go","matching_line":"    path_matcher = \"allpaths\""},{"context":"179:     name            = \"boop\"\n180:     path_rule {\n181:       paths   = [\"/*\"]\n182:       service = google_compute_backend_service.foobar.self_link\n183:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_https_proxy_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"1135: \t\t\t\t\t\t\tOptional:         true,\n1136: \t\t\t\t\t\t\tDiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,\n1137: \t\t\t\t\t\t\tDescription:      `The backend service or backend bucket to use when none of the given paths match.`,\n1138: \t\t\t\t\t\t},\n1139: \t\t\t\t\t\t\"default_url_redirect\": {\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map.go","matching_line":"\t\t\t\t\t\t\tDescription:      `The backend service or backend bucket to use when none of the given paths match.`,"},{"context":"71:   host_rule {\n72:     hosts        = [\"myothersite.com\"]\n73:     path_matcher = \"otherpaths\"\n74:   }\n75: \n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map_generated_test.go","matching_line":"    path_matcher = \"otherpaths\""},{"context":"393: \n394:     path_rule {\n395:       paths   = [\"/*\"]\n396:       service = google_compute_backend_service.foobar.self_link\n397:     }\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map_test.go","matching_line":"      paths   = [\"/*\"]"},{"context":"250: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tType:     schema.TypeList,\n251: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOptional: true,\n252: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tDescription: `A list of regular expressions matching file paths to exclude. All files in the bucket that match at\n253: least one of these regular expressions will be excluded from the scan.`,\n254: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tElem: \u0026schema.Schema{\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/datalossprevention/resource_data_loss_prevention_job_trigger.go","matching_line":"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tDescription: `A list of regular expressions matching file paths to exclude. All files in the bucket that match at"},{"context":"2064: \t\t\t\tRequired:    true,\n2065: \t\t\t\tForceNew:    true,\n2066: \t\t\t\tDescription: \"Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args\",\n2067: \t\t\t\tElem:        \u0026schema.Schema{Type: schema.TypeString},\n2068: \t\t\t},\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/dataproc/resource_dataproc_workflow_template.go","matching_line":"\t\t\t\tDescription: \"Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args\","},{"context":"90: func resourceDatastreamStreamDatabaseIdDiffSuppress(_, old, new string, _ *schema.ResourceData) bool {\n91: \tre := regexp.MustCompile(`projects/(.+)/datasets/([^\\.\\?\\#]+)`)\n92: \tpaths := re.FindStringSubmatch(new)\n93: \n94: \t// db returns value in form \u003cproject\u003e:\u003cdataset_id\u003e\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/datastream/resource_datastream_stream.go","matching_line":"\tpaths := re.FindStringSubmatch(new)"},{"context":"129: \t\t\t\t\t\t\t\t\t\tType:        schema.TypeList,\n130: \t\t\t\t\t\t\t\t\t\tRequired:    true,\n131: \t\t\t\t\t\t\t\t\t\tDescription: `The routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.`,\n132: \t\t\t\t\t\t\t\t\t\tMinItems:    1,\n133: \t\t\t\t\t\t\t\t\t\tMaxItems:    200,\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/networkservices/resource_network_services_edge_cache_service.go","matching_line":"\t\t\t\t\t\t\t\t\t\tDescription: `The routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.`,"},{"context":"80: schemes:\n81: - \"https\"\n82: paths:\n83:   \"/echo\":\n84:     post:\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/servicemanagement/resource_endpoints_service_test.go","matching_line":"paths:"},{"context":"237: \t\t\t\t\t\t\tType:        schema.TypeList,\n238: \t\t\t\t\t\t\tComputed:    true,\n239: \t\t\t\t\t\t\tDescription: `Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.`,\n240: \t\t\t\t\t\t\tElem: \u0026schema.Resource{\n241: \t\t\t\t\t\t\t\tSchema: map[string]*schema.Schema{\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/vertexai/resource_vertex_ai_endpoint.go","matching_line":"\t\t\t\t\t\t\tDescription: `Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.`,"},{"context":"14: )\n15: \n16: // Compare only the resource name of two self links/paths.\n17: func CompareResourceNames(_, old, new string, _ *schema.ResourceData) bool {\n18: \treturn GetResourceNameFromSelfLink(old) == GetResourceNameFromSelfLink(new)\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource/self_link_helpers.go","matching_line":"// Compare only the resource name of two self links/paths."},{"context":"452: const TagsLocationBasePathKey = \"TagsLocation\"\n453: \n454: // Generated product base paths\n455: var DefaultBasePaths = map[string]string{\n456: \tAccessApprovalBasePathKey:           \"https://accessapproval.googleapis.com/v1/\",\n","filename":"third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go","matching_line":"// Generated product base paths"}],"result":"success"}


I0219 07:02:22.411331  460137 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:[map[context:191: 	}
192: 
193: 	// a map of supported connection types to the corresponding status paths to service acocunt ID
194: 	serviceAccountPaths := map[string][]string{
195: 		"cloudSQL":      {"status", "observedState", "cloudSQL", "serviceAccountID"},
 filename:apis/bigqueryconnection/v1beta1/connection_reference.go matching_line:	// a map of supported connection types to the corresponding status paths to service acocunt ID] map[context:102: 	}
103: 
104: 	// For organization and folder paths, only expect 2 parts
105: 	if parts[0] == "organizations" || parts[0] == "folders" {
106: 		if len(parts) != 2 {
 filename:apis/iap/v1alpha1/iapsettings_identity.go matching_line:	// For organization and folder paths, only expect 2 parts] map[context:75: 	ProducerInstanceLocation *string `json:"producerInstanceLocation,omitempty"`
76: 
77: 	// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
78: 	Subnetworks []refs.ComputeSubnetworkRef `json:"subnetworkRefs,omitempty"`
79: }
 filename:apis/networkconnectivity/v1alpha1/serviceconnectionpolicy_types.go matching_line:	// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.] map[context:937: 		case "containeranalysisnote":
938: 		case "dataproccluster":
939: 		case "cloudstoragepathstoredinfotype":
940: 		case "dnsrecordset":
941: 		case "eventarctrigger":
 filename:config/tests/samples/create/harness.go matching_line:		case "cloudstoragepathstoredinfotype":] map[context:206: 	}
207: 
208: 	paths := []string{}
209: 	// Option 1: This option is good for proto that has ` + "`" + `field_mask` + "`" + ` for output-only, immutable, required/optional.
210: 	// TODO(contributor): If choosing this option, remove the "Option 2" code.
 filename:dev/tools/controllerbuilder/template/controller/controller.go matching_line:	paths := []string{}] map[context:15: package api
16: 
17: //go:generate go run sigs.k8s.io/controller-tools/cmd/controller-gen@v0.8.0 object crd:crdVersions=v1 output:crd:artifacts:config=../config/crd/ paths="./..."
18: 
 filename:experiments/composite/api/generate.go matching_line://go:generate go run sigs.k8s.io/controller-tools/cmd/controller-gen@v0.8.0 object crd:crdVersions=v1 output:crd:artifacts:config=../config/crd/ paths="./..."] map[context:22: 
23: // Note: The functions below can be used in Polling because they are called on
24: // paths holding fields that should absolutely be of the specified type. If not,
25: // there is a fundamental error in which case we can exit the test immediately
26: // instead of telling Poll to err.
 filename:experiments/compositions/composition/tests/testclient/unstructured.go matching_line:// paths holding fields that should absolutely be of the specified type. If not,] map[context:34: // The value of path / prefix should match whatever the API defines as its
35: // operations endpoint, which is often most conveniently determined by looking
36: // at the API documentation, or by seeing what paths clients request.
37: func (s *Operations) RegisterOperationsPath(path string) func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
38: 	return func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
 filename:mockgcp/common/operations/http.go matching_line:// at the API documentation, or by seeing what paths clients request.] map[context:190: 	// Fix our mockgcp hack:
191: 	// The protobuf libraries get upset if we have two proto message types
192: 	// with the same proto path, but different go paths.
193: 	// The go client SDK for GCP uses the protos for some services,
194: 	// so we need to "get out of the way" to avoid conflicts.
 filename:mockgcp/common/operations/operations.go matching_line:	// with the same proto path, but different go paths.] map[context:1093: 	unknownFields protoimpl.UnknownFields
1094: 
1095: 	// Response does not include the possible roles of a member since the behavior of this rpc is not all-or-nothing unlike the other rpcs. So, it may not be possible to list all the roles definitively, due to possible lack of authorization in some of the paths.
1096: 	HasMembership *bool `protobuf:"varint,1,opt,name=has_membership,json=hasMembership" json:"has_membership,omitempty"`
1097: }
 filename:mockgcp/generated/google/apps/cloudidentity/groups/v1beta1/service.pb.go matching_line:	// Response does not include the possible roles of a member since the behavior of this rpc is not all-or-nothing unlike the other rpcs. So, it may not be possible to list all the roles definitively, due to possible lack of authorization in some of the paths.] map[context:1474: 	// Retrieves a `Membership`.
1475: 	GetGroupsMembership(ctx context.Context, in *GetGroupsMembershipRequest, opts ...grpc.CallOption) (*Membership, error)
1476: 	// Get a membership graph of just a member or both a member and a group. **Note:** This feature is only available to Google Workspace Enterprise Standard, Enterprise Plus, and Enterprise for Education; and Cloud Identity Premium accounts. Given a member, the response will contain all membership paths from the member. Given both a group and a member, the response will contain all membership paths between the group and the member.
1477: 	GetMembershipGraphGroupsMembership(ctx context.Context, in *GetMembershipGraphGroupsMembershipRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
1478: 	// Lists the `Membership`s within a `Group`.
 filename:mockgcp/generated/google/apps/cloudidentity/groups/v1beta1/service_grpc.pb.go matching_line:	// Get a membership graph of just a member or both a member and a group. **Note:** This feature is only available to Google Workspace Enterprise Standard, Enterprise Plus, and Enterprise for Education; and Cloud Identity Premium accounts. Given a member, the response will contain all membership paths from the member. Given both a group and a member, the response will contain all membership paths between the group and the member.] map[context:784: 	// All of the files that are exported in this export operation. For custom
785: 	// code training export, only three (training, validation and test)
786: 	// Cloud Storage paths in wildcard format are populated
787: 	// (for example, gs://.../training-*).
788: 	ExportedFiles []string `protobuf:"bytes,1,rep,name=exported_files,json=exportedFiles,proto3" json:"exported_files,omitempty"`
 filename:mockgcp/generated/mockgcp/cloud/aiplatform/v1beta1/dataset_service.pb.go matching_line:	// Cloud Storage paths in wildcard format are populated] map[context:344: 	// Estimate your costs before enabling this option.
345: 	EnableAccessLogging bool `protobuf:"varint,13,opt,name=enable_access_logging,json=enableAccessLogging,proto3" json:"enable_access_logging,omitempty"`
346: 	// Output only. Provide paths for users to send predict/explain/health
347: 	// requests directly to the deployed model services running on Cloud via
348: 	// private services access. This field is populated if
 filename:mockgcp/generated/mockgcp/cloud/aiplatform/v1beta1/endpoint.pb.go matching_line:	// Output only. Provide paths for users to send predict/explain/health] map[context:1581: 	unknownFields protoimpl.UnknownFields
1582: 
1583: 	// Comma-separated list of API resources to be bundled in the API product. By default, the resource paths are mapped from the `proxy.pathsuffix` variable. The proxy path suffix is defined as the URI fragment following the ProxyEndpoint base path. For example, if the `apiResources` element is defined to be `/forecastrss` and the base path defined for the API proxy is `/weather`, then only requests to `/weather/forecastrss` are permitted by the API product. You can select a specific path, or you can select all subpaths with the following wildcard: - `/**`: Indicates that all sub-URIs are included. - `/*` : Indicates that only URIs one level down are included. By default, / supports the same resources as /** as well as the base path defined by the API proxy. For example, if the base path of the API proxy is `/v1/weatherapikey`, then the API product supports requests to `/v1/weatherapikey` and to any sub-URIs, such as `/v1/weatherapikey/forecastrss`, `/v1/weatherapikey/region/CA`, and so on. For more information, see Managing API products.
1584: 	ApiResources []string `protobuf:"bytes,1,rep,name=api_resources,json=apiResources,proto3" json:"api_resources,omitempty"`
1585: 	// Flag that specifies how API keys are approved to access the APIs defined by the API product. If set to `manual`, the consumer key is generated and returned in "pending" state. In this case, the API keys won't work until they have been explicitly approved. If set to `auto`, the consumer key is generated and returned in "approved" state and can be used immediately. **Note:** Typically, `auto` is used to provide access to free or trial API products that provide limited quota or capabilities.
 filename:mockgcp/generated/mockgcp/cloud/apigee/v1/service.pb.go matching_line:	// Comma-separated list of API resources to be bundled in the API product. By default, the resource paths are mapped from the `proxy.pathsuffix` variable. The proxy path suffix is defined as the URI fragment following the ProxyEndpoint base path. For example, if the `apiResources` element is defined to be `/forecastrss` and the base path defined for the API proxy is `/weather`, then only requests to `/weather/forecastrss` are permitted by the API product. You can select a specific path, or you can select all subpaths with the following wildcard: - `/**`: Indicates that all sub-URIs are included. - `/*` : Indicates that only URIs one level down are included. By default, / supports the same resources as /** as well as the base path defined by the API proxy. For example, if the base path of the API proxy is `/v1/weatherapikey`, then the API product supports requests to `/v1/weatherapikey` and to any sub-URIs, such as `/v1/weatherapikey/forecastrss`, `/v1/weatherapikey/region/CA`, and so on. For more information, see Managing API products.] map[context:14266: 	// REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them.
14267: 	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
14268: 	// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"`
14269: 	UpdateMask *string `protobuf:"bytes,2,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
14270: }
 filename:mockgcp/generated/mockgcp/cloud/bigquery/v2/api.pb.go matching_line:	// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"`] map[context:683: 
684: type TrustConfig_IntermediateCA_PemCertificate struct {
685: 	// PEM intermediate certificate used for building up paths
686: 	// for validation.
687: 	//
 filename:mockgcp/generated/mockgcp/cloud/certificatemanager/v1/trust_config.pb.go matching_line:	// PEM intermediate certificate used for building up paths] map[context:101958: 	// The body resource for this request
101959: 	NetworkEdgeSecurityServiceResource *NetworkEdgeSecurityService `protobuf:"bytes,477548966,opt,name=network_edge_security_service_resource,json=networkEdgeSecurityServiceResource,proto3" json:"network_edge_security_service_resource,omitempty"`
101960: 	Paths                              *string                     `protobuf:"bytes,106438894,opt,name=paths,proto3,oneof" json:"paths,omitempty"`
101961: 	// Project ID for this request.
101962: 	Project string `protobuf:"bytes,227560217,opt,name=project,proto3" json:"project,omitempty"`
 filename:mockgcp/generated/mockgcp/cloud/compute/v1/compute.pb.go matching_line:	Paths                              *string                     `protobuf:"bytes,106438894,opt,name=paths,proto3,oneof" json:"paths,omitempty"`] map[context:1145: 	// root. If left unset, the root is used.
1146: 	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
1147: 	// Optional. Maximum number of paths to return. The server may return fewer
1148: 	// items than requested. If unspecified, the server will pick an appropriate
1149: 	// default.
 filename:mockgcp/generated/mockgcp/cloud/dataform/v1beta1/dataform.pb.go matching_line:	// Optional. Maximum number of paths to return. The server may return fewer] map[context:1215: 
1216: 	// Mask of fields to update.  At least one path must be supplied in this
1217: 	// field.  The elements of the repeated paths field may only include these
1218: 	// fields:
1219: 	//
 filename:mockgcp/generated/mockgcp/cloud/filestore/v1/cloud_filestore_service.pb.go matching_line:	// field.  The elements of the repeated paths field may only include these] map[context:916: 	//
917: 	// To refer to a specific commit:
918: 	// `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`
919: 	// To refer to a moveable alias (branch):
920: 	// `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`
 filename:mockgcp/generated/mockgcp/cloud/functions/v1/functions.pb.go matching_line:	// `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`] map[context:404: 	ValidateOnly bool `protobuf:"varint,2,opt,name=validate_only,json=validateOnly,proto3" json:"validate_only,omitempty"`
405: 	// Required. Mask of fields to update. At least one path must be supplied in
406: 	// this field. The elements of the repeated paths field can only include these
407: 	// fields from
408: 	// [AttachedCluster][mockgcp.cloud.gkemulticloud.v1.AttachedCluster]:
 filename:mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/attached_service.pb.go matching_line:	// this field. The elements of the repeated paths field can only include these] map[context:144: 	ValidateOnly bool `protobuf:"varint,2,opt,name=validate_only,json=validateOnly,proto3" json:"validate_only,omitempty"`
145: 	// Required. Mask of fields to update. At least one path must be supplied in
146: 	// this field. The elements of the repeated paths field can only include these
147: 	// fields from [AwsCluster][mockgcp.cloud.gkemulticloud.v1.AwsCluster]:
148: 	//
 filename:mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/aws_service.pb.go matching_line:	// this field. The elements of the repeated paths field can only include these] map[context:144: 	ValidateOnly bool `protobuf:"varint,2,opt,name=validate_only,json=validateOnly,proto3" json:"validate_only,omitempty"`
145: 	// Required. Mask of fields to update. At least one path must be supplied in
146: 	// this field. The elements of the repeated paths field can only include these
147: 	// fields from [AzureCluster][mockgcp.cloud.gkemulticloud.v1.AzureCluster]:
148: 	//
 filename:mockgcp/generated/mockgcp/cloud/gkemulticloud/v1/azure_service.pb.go matching_line:	// this field. The elements of the repeated paths field can only include these] map[context:982: 	// REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them.
983: 	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
984: 	// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"`
985: 	UpdateMask *string `protobuf:"bytes,2,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
986: }
 filename:mockgcp/generated/mockgcp/cloud/ids/v1/service.pb.go matching_line:	// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"`] map[context:3824: 	// Required. ProducerInstanceLocation is used to specify which authorization mechanism to use to determine which projects the Producer instance can be within.
3825: 	ProducerInstanceLocation string `protobuf:"bytes,3,opt,name=producer_instance_location,json=producerInstanceLocation,proto3" json:"producer_instance_location,omitempty"`
3826: 	// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
3827: 	Subnetworks []string `protobuf:"bytes,4,rep,name=subnetworks,proto3" json:"subnetworks,omitempty"`
3828: }
 filename:mockgcp/generated/mockgcp/cloud/networkconnectivity/v1/networkconnectivity.pb.go matching_line:	// The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.] map[context:101: 	// Will only match the exact value provided.
102: 	GrpcRoute_HeaderMatch_EXACT GrpcRoute_HeaderMatch_Type = 1
103: 	// Will match paths conforming to the prefix specified by value. RE2
104: 	// syntax is supported.
105: 	GrpcRoute_HeaderMatch_REGULAR_EXPRESSION GrpcRoute_HeaderMatch_Type = 2
 filename:mockgcp/generated/mockgcp/cloud/networkservices/v1/grpc_route.pb.go matching_line:	// Will match paths conforming to the prefix specified by value. RE2] map[context:1383: 	// if, it is in the mask. Any immutable fields set in the mask are ignored by
1384: 	// the server. Repeated fields and map fields are only allowed in the last
1385: 	// position of a `paths` string and overwrite the existing values. Hence an
1386: 	// update to a repeated field or a map should contain the entire list of
1387: 	// values. The fields specified in the update_mask are relative to the
 filename:mockgcp/generated/mockgcp/cloud/privilegedaccessmanager/v1/privilegedaccessmanager.pb.go matching_line:	// position of a `paths` string and overwrite the existing values. Hence an] map[context:754: 
755: 	// Required. Mask of fields to update. At least one path must be supplied in
756: 	// this field. The elements of the repeated paths field may only include these
757: 	// fields from [Cluster][mockgcp.cloud.redis.cluster.v1.Cluster]:
758: 	//
 filename:mockgcp/generated/mockgcp/cloud/redis/cluster/v1/cloud_redis_cluster.pb.go matching_line:	// this field. The elements of the repeated paths field may only include these] map[context:1806: 
1807: 	// Required. Mask of fields to update. At least one path must be supplied in
1808: 	// this field. The elements of the repeated paths field may only include these
1809: 	// fields from [Instance][mockgcp.cloud.redis.v1beta1.Instance]:
1810: 	//
 filename:mockgcp/generated/mockgcp/cloud/redis/v1beta1/cloud_redis.pb.go matching_line:	// this field. The elements of the repeated paths field may only include these] map[context:3556: 	// Specifies the resource type for the resource referred to by the field.
3557: 	ResourceType string `protobuf:"bytes,2,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
3558: 	// Selects one or more request or response message fields to apply this `FieldPolicy`. When a `FieldPolicy` is used in proto annotation, the selector must be left as empty. The service config generator will automatically fill the correct value. When a `FieldPolicy` is used in service config, the selector must be a comma-separated string with valid request or response field paths, such as "foo.bar" or "foo.bar,foo.baz".
3559: 	Selector string `protobuf:"bytes,3,opt,name=selector,proto3" json:"selector,omitempty"`
3560: }
 filename:mockgcp/generated/mockgcp/cloud/servicenetworking/v1/servicenetworking.pb.go matching_line:	// Selects one or more request or response message fields to apply this `FieldPolicy`. When a `FieldPolicy` is used in proto annotation, the selector must be left as empty. The service config generator will automatically fill the correct value. When a `FieldPolicy` is used in service config, the selector must be a comma-separated string with valid request or response field paths, such as "foo.bar" or "foo.bar,foo.baz".] map[context:192: 	unknownFields protoimpl.UnknownFields
193: 
194: 	// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
195: 	Uris []string `protobuf:"bytes,1,rep,name=uris,proto3" json:"uris,omitempty"`
196: 	// Supports URI wildcards for matching multiple objects from a single URI.
 filename:mockgcp/generated/mockgcp/devtools/artifactregistry/v1/apt_artifact.pb.go matching_line:	// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).] map[context:172: 	unknownFields protoimpl.UnknownFields
173: 
174: 	// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
175: 	Uris []string `protobuf:"bytes,1,rep,name=uris,proto3" json:"uris,omitempty"`
176: 	// Supports URI wildcards for matching multiple objects from a single URI.
 filename:mockgcp/generated/mockgcp/devtools/artifactregistry/v1/yum_artifact.pb.go matching_line:	// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).] map[context:2524: 	// Path at which to mount the volume.
2525: 	//
2526: 	// Paths must be absolute and cannot conflict with other volume paths on the
2527: 	// same build step or with certain reserved volume paths.
2528: 	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
 filename:mockgcp/generated/mockgcp/devtools/cloudbuild/v1/cloudbuild.pb.go matching_line:	// Paths must be absolute and cannot conflict with other volume paths on the] map[context:117: 	// represents any field.
118: 	//
119: 	// Field paths can be quoted using “ ` “ (backtick). The only character that
120: 	// must be escaped within a quoted field path is the backtick character
121: 	// itself, escaped using a backslash. Special characters in field paths that
 filename:mockgcp/generated/mockgcp/firestore/admin/v1/field.pb.go matching_line:	// Field paths can be quoted using “ ` “ (backtick). The only character that] map[context:43: 	// [FirestoreAdmin.UpdateField][mockgcp.firestore.admin.v1.FirestoreAdmin.UpdateField]
44: 	// should provide a field mask to avoid changing any configuration that the
45: 	// caller isn't aware of. The field mask should be specified as: `{ paths:
46: 	// "index_config" }`.
47: 	//
 filename:mockgcp/generated/mockgcp/firestore/admin/v1/firestore_admin_grpc.pb.go matching_line:	// caller isn't aware of. The field mask should be specified as: `{ paths:] map[context:297: 	// Required. The LogEntry field path to index.
298: 	//
299: 	// Note that some paths are automatically indexed, and other paths are not
300: 	// eligible for indexing. See [indexing documentation](
301: 	// https://cloud.google.com/logging/docs/view/advanced-queries#indexed-fields)
 filename:mockgcp/generated/mockgcp/logging/v2/logging_config.pb.go matching_line:	// Note that some paths are automatically indexed, and other paths are not] map[context:73: 	// verified state, this method will fail (in other words, this may only be
74: 	// used if the SendNotificationChannelVerificationCode and
75: 	// VerifyNotificationChannel paths have already been used to put the given
76: 	// channel into the verified state).
77: 	//
 filename:mockgcp/generated/mockgcp/monitoring/v3/notification_service_grpc.pb.go matching_line:	// VerifyNotificationChannel paths have already been used to put the given] map[context:331: 	// The given `name` specifies the resource to update.
332: 	Service *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
333: 	// A set of field paths defining which fields to use for the update.
334: 	UpdateMask *field_mask.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
335: }
 filename:mockgcp/generated/mockgcp/monitoring/v3/service_service.pb.go matching_line:	// A set of field paths defining which fields to use for the update.] map[context:267: 	// source integrity was maintained in the build.
268: 	//
269: 	// The keys to this map are file paths used as build source and the values
270: 	// contain the hash values for those files.
271: 	//
 filename:mockgcp/generated/mockgrafeas/v1/provenance.pb.go matching_line:	// The keys to this map are file paths used as build source and the values] map[context:216: 
217: 	// Required. A list of fields to be updated in this request.
218: 	paths := req.GetUpdateMask().GetPaths()
219: 
220: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockalloydb/cluster.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:186: 
187: 	// Required. A list of fields to be updated in this request.
188: 	paths := req.GetUpdateMask().GetPaths()
189: 
190: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockalloydb/instance.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:105: 
106: 	// Required. A list of fields to be updated in this request.
107: 	paths := req.GetUpdateMask()
108: 	fieldMask, err := field_mask.New(obj, strings.Split(paths, ",")...)
109: 	if err != nil {
 filename:mockgcp/mockapigee/envgroup.go matching_line:	paths := req.GetUpdateMask()] map[context:126: 
127: 	// Required. A list of fields to be updated in this request.
128: 	paths := req.GetUpdateMask()
129: 	fieldMask, err := fieldmaskpb.New(obj, strings.Split(paths, ",")...)
130: 	if err != nil {
 filename:mockgcp/mockapigee/instance.go matching_line:	paths := req.GetUpdateMask()] map[context:98: 
99: 	// Required. A list of fields to be updated in this request.
100: 	paths := req.GetUpdateMask().GetPaths()
101: 
102: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockartifactregistry/repository.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:205: 
206: 	if err := fields.UpdateByFieldMask(obj, req.Connection, req.UpdateMask.Paths); err != nil {
207: 		return nil, fmt.Errorf("update field_mask.paths: %w", err)
208: 	}
209: 	obj.LastModifiedTime = now.Unix()
 filename:mockgcp/mockbigqueryconnection/connection.go matching_line:		return nil, fmt.Errorf("update field_mask.paths: %w", err)] map[context:148: 	}
149: 
150: 	paths := req.GetUpdateMask().GetPaths()
151: 	for _, path := range paths {
152: 		switch path {
 filename:mockgcp/mockbigquerydatatransfer/datatransfer.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:107: 
108: 	if err := fields.UpdateByFieldMask(obj, req.Reservation, req.UpdateMask.Paths); err != nil {
109: 		return nil, fmt.Errorf("update field_mask.paths: %w", err)
110: 	}
111: 
 filename:mockgcp/mockbigqueryreservation/reservation.go matching_line:		return nil, fmt.Errorf("update field_mask.paths: %w", err)] map[context:94: 
95: 	// Required. The update mask applies to the resource.
96: 	paths := req.GetUpdateMask().GetPaths()
97: 	if len(paths) == 0 {
98: 		klog.Warningf("update_mask was not provided in request, should be required")
 filename:mockgcp/mockcertificatemanager/certificate.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:94: 
95: 	// Required. The update mask applies to the resource.
96: 	paths := req.GetUpdateMask().GetPaths()
97: 	if len(paths) == 0 {
98: 		klog.Warningf("update_mask was not provided in request, should be required")
 filename:mockgcp/mockcertificatemanager/certificatemap.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:94: 
95: 	// Required. The update mask applies to the resource.
96: 	paths := req.GetUpdateMask().GetPaths()
97: 	if len(paths) == 0 {
98: 		klog.Warningf("update_mask was not provided in request, should be required")
 filename:mockgcp/mockcertificatemanager/certificatemapentry.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:102: 
103: 	// Required. The update mask applies to the resource.
104: 	paths := req.GetUpdateMask().GetPaths()
105: 	if len(paths) == 0 {
106: 		klog.Warningf("update_mask was not provided in request, should be required")
 filename:mockgcp/mockcertificatemanager/dnsauthorization.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:81: 
82: 	// Required. The update mask applies to the resource.
83: 	paths := req.GetUpdateMask().GetPaths()
84: 	if len(paths) == 0 {
85: 		klog.Warningf("update_mask was not provided in request, should be required")
 filename:mockgcp/mockcloudfunctions/v1.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:133: 	}
134: 
135: 	paths := strings.Split(request.GetUpdateMask(), ",")
136: 	for _, path := range paths {
137: 		switch path {
 filename:mockgcp/mockcloudids/endpoint.go matching_line:	paths := strings.Split(request.GetUpdateMask(), ",")] map[context:96: 
97: 	// Required. A list of fields to be updated in this request.
98: 	paths := req.GetUpdateMask().GetPaths()
99: 
100: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockcontaineranalysis/note.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:98: 	}
99: 
100: 	paths := req.GetUpdateMask().GetPaths()
101: 	if len(paths) == 0 {
102: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask must be provided")
 filename:mockgcp/mockdiscoveryengine/datastore.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:141: 	}
142: 
143: 	paths := req.GetUpdateMask().GetPaths()
144: 	if len(paths) == 0 {
145: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask must be provided")
 filename:mockgcp/mockfilestore/instance.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:106: 	obj.UpdateTime = now
107: 	// Required. A list of fields to be updated in this request.
108: 	paths := req.GetUpdateMask().GetPaths()
109: 
110: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockgkehub/gkehubfeature.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:106: 	now := timestamppb.Now()
107: 	// Required. A list of fields to be updated in this request.
108: 	paths := req.GetUpdateMask().GetPaths()
109: 
110: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockgkehub/gkehubmembership.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:122: 	}
123: 	// Mask of fields to update. At least one path must be supplied in
124: 	// this field. The elements of the repeated paths field can only include these
125: 	// fields from
126: 	// [AttachedCluster][mockgcp.cloud.gkemulticloud.v1.AttachedCluster]:
 filename:mockgcp/mockgkemulticloud/attachedcluster.go matching_line:	// this field. The elements of the repeated paths field can only include these] map[context:164: 	// You can patch only the `display_name` and `description` fields.
165: 	// You must use the `update_mask` field to specify which of these fields you want to patch.
166: 	paths := req.GetUpdateMask().GetPaths()
167: 	for _, path := range paths {
168: 		switch path {
 filename:mockgcp/mockiam/serviceaccounts.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:149: 
150: 	// Required. The update mask applies to the resource.
151: 	paths := req.GetUpdateMask().GetPaths()
152: 	if len(paths) == 0 {
153: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask is required")
 filename:mockgcp/mocklogging/logbucket.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:99: 	updated := proto.Clone(existing).(*pb.LogSink)
100: 
101: 	paths := req.GetUpdateMask().GetPaths()
102: 	if len(paths) == 0 {
103: 		// Optional, but we require it in our mock.
 filename:mockgcp/mocklogging/logsink.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:85: 
86: 	// Required. The update mask applies to the resource.
87: 	paths := req.GetUpdateMask().GetPaths()
88: 	if len(paths) == 0 {
89: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask is required by mock")
 filename:mockgcp/mocklogging/logview.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:113: 		return nil, err
114: 	}
115: 	paths := req.GetUpdateMask().GetPaths()
116: 	if len(paths) == 0 {
117: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask must be provided")
 filename:mockgcp/mockmanagedkafka/cluster.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:140: 
141: 	if req.GetUpdateMask() != "" {
142: 		paths := strings.Split(req.GetUpdateMask(), ",")
143: 
144: 		patch := req.GetProjectsLocationsServiceConnectionPolicy()
 filename:mockgcp/mocknetworkconnectivity/serviceconnectionpolicies.go matching_line:		paths := strings.Split(req.GetUpdateMask(), ",")] map[context:88: 	// the full request. A field will be overwritten if it is in the mask. If the
89: 	// user does not provide a mask then all fields will be overwritten.
90: 	paths := req.GetUpdateMask().GetPaths()
91: 	// TODO: Some sort of helper for fieldmask?
92: 	for _, path := range paths {
 filename:mockgcp/mocknetworkservices/networkservices.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:120: 
121: 	// Required. A list of fields to be updated in this request.
122: 	paths := req.GetUpdateMask().GetPaths()
123: 
124: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockprivateca/capool.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:96: 
97: 	// Required. A list of fields to be updated in this request.
98: 	paths := req.GetUpdateMask().GetPaths()
99: 
100: 	for _, path := range paths {
 filename:mockgcp/mockprivilegedaccessmanager/entitlement.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:99: 
100: 	// Required. The update mask applies to the resource.
101: 	paths := req.GetUpdateMask().GetPaths()
102: 	if len(paths) == 0 {
103: 		// Documented as required, but not passed by terraform...
 filename:mockgcp/mockpubsub/subscription.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:102: 
103: 	// Required. The update mask applies to the resource.
104: 	paths := req.GetUpdateMask().GetPaths()
105: 	if len(paths) == 0 {
106: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask is required")
 filename:mockgcp/mockpubsub/topic.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:83: 
84: 	// Required. A list of fields to be updated in this request.
85: 	paths := req.GetUpdateMask().GetPaths()
86: 
87: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockpubsublite/reservation.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:82: 
83: 	// Required. A list of fields to be updated in this request.
84: 	paths := req.GetUpdateMask().GetPaths()
85: 
86: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockpubsublite/subscription.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:82: 
83: 	// Required. A list of fields to be updated in this request.
84: 	paths := req.GetUpdateMask().GetPaths()
85: 
86: 	// TODO: Some sort of helper for fieldmask?
 filename:mockgcp/mockpubsublite/topic.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:219: 
220: 	// Required. Mask of fields to update. At least one path must be supplied in
221: 	// this field. The elements of the repeated paths field may only include these
222: 	// fields from [Cluster][mockgcp.cloud.redis.cluster.v1.Cluster]:
223: 	//
 filename:mockgcp/mockredis/cluster.go matching_line:	// this field. The elements of the repeated paths field may only include these] map[context:178: 
179: 	// Required. Mask of fields to update. At least one path must be supplied in
180: 	// this field. The elements of the repeated paths field may only include these
181: 	// fields from Instance:
182: 	//
 filename:mockgcp/mockredis/instance.go matching_line:	// this field. The elements of the repeated paths field may only include these] map[context:118: 	// Only the `display_name` field can be changed.
119: 
120: 	paths := req.GetUpdateMask().GetPaths()
121: 	for _, path := range paths {
122: 		switch path {
 filename:mockgcp/mockresourcemanager/folders.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:177: 
178: // 	// Only the `display_name` and `labels` fields can be change.
179: // 	paths := req.GetUpdateMask().GetPaths()
180: // 	if len(paths) == 0 {
181: // 		if len(req.GetProject().GetLabels()) != 0 {
 filename:mockgcp/mockresourcemanager/projects_internal.go matching_line:// 	paths := req.GetUpdateMask().GetPaths()] map[context:96: func (s *ProjectsV3) UpdateProject(ctx context.Context, req *pb.UpdateProjectRequest) (*longrunningpb.Operation, error) {
97: 	mutator := func(obj *pb.Project) error { // Only the `display_name` and `labels` fields can be change.
98: 		paths := req.GetUpdateMask().GetPaths()
99: 		if len(paths) == 0 {
100: 			if len(req.GetProject().GetLabels()) != 0 {
 filename:mockgcp/mockresourcemanager/projectsv3.go matching_line:		paths := req.GetUpdateMask().GetPaths()] map[context:133: 	// `etag`. If omitted entirely, both `description` and `etag` are assumed to
134: 	// be significant.
135: 	paths := req.GetUpdateMask().GetPaths()
136: 	for _, path := range paths {
137: 		switch path {
 filename:mockgcp/mockresourcemanager/tagkeys.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:148: 	// We should verify that this is part of on of our projects, but ... it's a mock
149: 
150: 	paths := req.GetUpdateMask().GetPaths()
151: 	for _, path := range paths {
152: 		switch path {
 filename:mockgcp/mockresourcemanager/tagvalues.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:135: 
136: 	// Required. The update mask applies to the resource.
137: 	paths := req.GetUpdateMask().GetPaths()
138: 	if len(paths) == 0 {
139: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask is required")
 filename:mockgcp/mocksecretmanager/secrets.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:143: 
144: 	// Required. The update mask applies to the resource.
145: 	paths := req.GetUpdateMask().GetPaths()
146: 	if len(paths) == 0 {
147: 		return nil, status.Errorf(codes.InvalidArgument, "update_mask must be provided")
 filename:mockgcp/mockworkflows/workflow.go matching_line:	paths := req.GetUpdateMask().GetPaths()] map[context:25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s"
26: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest"
27: 	testpaths "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
28: 
29: 	"github.com/google/go-cmp/cmp"
 filename:operator/pkg/manifest/repo_test.go matching_line:	testpaths "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:33: 	corev1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/apis/core/v1beta1"
34: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/controllers"
35: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
36: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/kccmanager/nocache"
37: )
 filename:operator/pkg/test/main/testmain.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:13: // limitations under the License.
14: 
15: package paths
16: 
17: import (
 filename:operator/pkg/test/util/paths/paths.go matching_line:package paths] map[context:25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s"
26: 	cnrmmanifest "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest"
27: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
28: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/scripts/utils"
29: 
 filename:operator/scripts/copy-dependency-manifests/main.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:39: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s"
40: 	cnrmmanifest "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/manifest"
41: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
42: )
43: 
 filename:operator/scripts/generate-image-configmap/main.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:30: 
31: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s"
32: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
33: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/scripts/utils"
34: 	"github.com/blang/semver/v4"
 filename:operator/scripts/update-kcc-manifest/main.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:932: 	yamlPaths, err := getYAMLFilesInDir(repoYAMLDir)
933: 	if err != nil {
934: 		return "", "", fmt.Errorf("error getting paths to YAML files in ArtifactRegistryRepository sample directory '%v': %w", repoYAMLDir, err)
935: 	}
936: 	for _, yamlPath := range yamlPaths {
 filename:operator/tests/e2e/e2e_test.go matching_line:		return "", "", fmt.Errorf("error getting paths to YAML files in ArtifactRegistryRepository sample directory '%v': %w", repoYAMLDir, err)] map[context:199: 	// `status.observedState` in the CRD, and in the CR after a successful
200: 	// reconciliation.
201: 	// The fields should be snake case paths in TF. For example,
202: 	// `master_auth.client_certificate`.
203: 	ObservedFields *[]string `json:"observedFields,omitempty"`
 filename:pkg/apis/core/v1alpha1/servicemapping_types.go matching_line:	// The fields should be snake case paths in TF. For example,] map[context:232: // []interface{} and the same is true for each sub-key
233: //
234: // The reason why the map contains slices in the middle of paths is a terraform oddity where often times there can be a
235: // list of size 1 for various reasons
236: func getValueInSliceAwareNestedMap(object interface{}, path []string) (interface{}, bool, error) {
 filename:pkg/cli/gcpclient/resolve_apiserver_dependencies_test.go matching_line:// The reason why the map contains slices in the middle of paths is a terraform oddity where often times there can be a] map[context:423: 	RequireMatchingFile *bool `json:"requireMatchingFile,omitempty"`
424: 
425: 	/* Regular expression that matches the file paths for all files that should be referenced by this handler. */
426: 	// +optional
427: 	UploadPathRegex *string `json:"uploadPathRegex,omitempty"`
 filename:pkg/clients/generated/apis/appengine/v1alpha1/appengineflexibleappversion_types.go matching_line:	/* Regular expression that matches the file paths for all files that should be referenced by this handler. */] map[context:206: 	RequireMatchingFile *bool `json:"requireMatchingFile,omitempty"`
207: 
208: 	/* Regular expression that matches the file paths for all files that should be referenced by this handler. */
209: 	// +optional
210: 	UploadPathRegex *string `json:"uploadPathRegex,omitempty"`
 filename:pkg/clients/generated/apis/appengine/v1alpha1/appenginestandardappversion_types.go matching_line:	/* Regular expression that matches the file paths for all files that should be referenced by this handler. */] map[context:56: 	/* A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
57: 
58: 	Files in the workspace matching specified paths globs will be uploaded to the
59: 	Cloud Storage location using the builder service account's credentials.
60: 
 filename:pkg/clients/generated/apis/cloudbuild/v1beta1/cloudbuildtrigger_types.go matching_line:	Files in the workspace matching specified paths globs will be uploaded to the] map[context:81: 
82: 	To refer to a specific commit:
83: 	`https://source.developers.google.com/projects/* /repos/* /revisions/* /paths/*`
84: 	To refer to a moveable alias (branch):
85: 	`https://source.developers.google.com/projects/* /repos/* /moveable-aliases/* /paths/*`
 filename:pkg/clients/generated/apis/cloudfunctions/v1beta1/cloudfunctionsfunction_types.go matching_line:	`https://source.developers.google.com/projects/* /repos/* /revisions/* /paths/*`] map[context:466: 	are specified does not matter. Matches are always done on the longest-path-first
467: 	basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
468: 	irrespective of the order in which those paths appear in this list. Within a
469: 	given pathMatcher, only one of pathRules or routeRules must be set. */
470: 	// +optional
 filename:pkg/clients/generated/apis/compute/v1beta1/computeurlmap_types.go matching_line:	irrespective of the order in which those paths appear in this list. Within a] map[context:444: 	Description *string `json:"description,omitempty"`
445: 
446: 	/* Immutable. Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args */
447: 	Fields []string `json:"fields"`
448: 
 filename:pkg/clients/generated/apis/dataproc/v1beta1/dataprocworkflowtemplate_types.go matching_line:	/* Immutable. Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args */] map[context:452: 	BucketRef v1alpha1.ResourceRef `json:"bucketRef"`
453: 
454: 	/* A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub. */
455: 	// +optional
456: 	ExcludeRegex []string `json:"excludeRegex,omitempty"`
 filename:pkg/clients/generated/apis/dlp/v1beta1/dlpjobtrigger_types.go matching_line:	/* A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub. */] map[context:45: 	ProducerInstanceLocation *string `json:"producerInstanceLocation,omitempty"`
46: 
47: 	/* The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}. */
48: 	// +optional
49: 	SubnetworkRefs []v1alpha1.ResourceRef `json:"subnetworkRefs,omitempty"`
 filename:pkg/clients/generated/apis/networkconnectivity/v1alpha1/networkconnectivityserviceconnectionpolicy_types.go matching_line:	/* The resource paths of subnetworks to use for IP address management. Example: projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}. */] map[context:45: 
46: 	* 'PathGlobs'
47: 	* 'paths'
48: 	* 'acl'
49: 	* 'URLPrefix'
 filename:pkg/clients/generated/apis/networkservices/v1alpha1/networkservicesedgecacheservice_types.go matching_line:	* 'paths'] map[context:279: 		return mapCtx.Err()
280: 	}
281: 	paths, err := common.CompareProtoMessage(connection, a.actual, common.BasicDiff)
282: 	if err != nil {
283: 		return err
 filename:pkg/controller/direct/bigqueryconnection/connection_controller.go matching_line:	paths, err := common.CompareProtoMessage(connection, a.actual, common.BasicDiff)] map[context:269: 	wp.Etag = a.actual.Etag
270: 
271: 	paths, err := common.CompareProtoMessage(wp, a.actual, common.BasicDiff)
272: 	if err != nil {
273: 		return err
 filename:pkg/controller/direct/cloudbuild/workerpool_controller.go matching_line:	paths, err := common.CompareProtoMessage(wp, a.actual, common.BasicDiff)] map[context:137: 	}
138: 
139: 	paths := calculateUpdateMask(desiredPb, a.actual)
140: 	if len(paths) == 0 {
141: 		log.V(2).Info("no field needs update", "name", a.id.String())
 filename:pkg/controller/direct/iap/iapsettings_controller.go matching_line:	paths := calculateUpdateMask(desiredPb, a.actual)] map[context:116: }
117: 
118: // ListFieldDiffsForUnstructured returns a list of field paths where the values differ, for two unstructured objects.
119: func ListFieldDiffsForUnstructured(l, r *unstructured.Unstructured) ([]string, error) {
120: 	o := &objectDiffWalker{}
 filename:pkg/controller/direct/logging/diffs.go matching_line:// ListFieldDiffsForUnstructured returns a list of field paths where the values differ, for two unstructured objects.] map[context:290: 		if err != nil {
291: 			// Don't return an error as we're only logging
292: 			log.Error(err, "computing changed field paths (for logging)")
293: 		}
294: 		log.Info("updating logMetric", "diffs", diffs)
 filename:pkg/controller/direct/logging/logmetric_controller.go matching_line:			log.Error(err, "computing changed field paths (for logging)")] map[context:185: 	desiredPb.Name = a.id.String()
186: 
187: 	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
188: 	if err != nil {
189: 		return err
 filename:pkg/controller/direct/managedkafka/cluster_controller.go matching_line:	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)] map[context:167: 	desiredPb.Name = a.id.String()
168: 
169: 	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
170: 	if err != nil {
171: 		return err
 filename:pkg/controller/direct/managedkafka/topic_controller.go matching_line:	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)] map[context:174: 
175: 	var err error
176: 	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
177: 	if err != nil {
178: 		return err
 filename:pkg/controller/direct/migrationcenter/group_controller.go matching_line:	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)] map[context:47: 		)
48: 
49: 		// Widgets are under a few paths
50: 		widgetPaths := []string{
51: 			".grid_layout.widgets[]",
 filename:pkg/controller/direct/monitoring/roundtrip_test.go matching_line:		// Widgets are under a few paths] map[context:255: 	resource.Name = a.id.String()
256: 	resource.Etag = a.actual.Etag
257: 	paths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)
258: 	if err != nil {
259: 		return err
 filename:pkg/controller/direct/secretmanager/secret_controller.go matching_line:	paths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)] map[context:223: 	resource.Etag = a.actual.Etag
224: 
225: 	paths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)
226: 	if err != nil {
227: 		return err
 filename:pkg/controller/direct/workstations/config_controller.go matching_line:	paths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)] map[context:204: 	desiredPb.Etag = a.actual.Etag
205: 
206: 	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)
207: 	if err != nil {
208: 		return err
 filename:pkg/controller/direct/workstations/workstation_controller.go matching_line:	paths, err := common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff)] map[context:31: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s"
32: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text"
33: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
34: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/slice"
35: 
 filename:pkg/crd/crdgeneration/dcl2crdgeneration.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:22: 	"strings"
23: 
24: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text"
26: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/repo"
 filename:pkg/crd/crdloader/crdloader.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s"
26: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/label"
27: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
28: 
29: 	dclunstruct "github.com/GoogleCloudPlatform/declarative-resource-client-library/unstructured"
 filename:pkg/dcl/conversion/converter.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:21: 
22: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/dcl/constants"
23: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
24: 
25: 	"github.com/nasa9084/go-openapi"
 filename:pkg/dcl/extension/extension.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:16: 
17: import (
18: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
19: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/slice"
20: )
 filename:pkg/dcl/fields.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:29: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader"
30: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util"
31: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
32: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/typeutil"
33: 
 filename:pkg/dcl/kcclite/conversion.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:30: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader"
31: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util"
32: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
33: 
34: 	mmdcl "github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl"
 filename:pkg/dcl/livestate/fetchlivestate.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:26: 
27: func MutableButUnreadableFieldsAnnotationFor(r *Resource) (string, error) {
28: 	paths, err := getMutableButUnreadablePaths(r)
29: 	if err != nil {
30: 		return "", fmt.Errorf("error getting mutable-but-unreadable fields for resource: %w", err)
 filename:pkg/dcl/mutableunreadable.go matching_line:	paths, err := getMutableButUnreadablePaths(r)] map[context:22: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s"
23: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util"
24: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
25: 
26: 	"github.com/google/go-cmp/cmp"
 filename:pkg/dcl/mutableunreadable_test.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text"
26: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util"
27: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
28: 
29: 	"github.com/nasa9084/go-openapi"
 filename:pkg/dcl/references.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:23: 
24: func MutableButUnreadableFieldsAnnotationFor(r *Resource) (string, error) {
25: 	paths := getMutableButUnreadablePaths(r)
26: 	return k8s.GenerateMutableButUnreadableFieldsAnnotation(&r.Resource, paths)
27: }
 filename:pkg/krmtotf/mutableunreadable.go matching_line:	paths := getMutableButUnreadablePaths(r)] map[context:582: }
583: 
584: // validateAtMostOneFieldIsSetUnderSlice returns error if both field paths within the slice field are set
585: func validateAtMostOneFieldIsSetUnderSlice(r *k8s.Resource, fieldPathUpToSlice, fieldPath1, fieldPath2 []string) error {
586: 	sliceField, found, err := unstructured.NestedSlice(r.Spec, fieldPathUpToSlice...)
 filename:pkg/resourceoverrides/utils.go matching_line:// validateAtMostOneFieldIsSetUnderSlice returns error if both field paths within the slice field are set] map[context:53: 		"datafusion":              {"datafusioninstance"},
54: 		"dataproc":                {"dataproccluster"},
55: 		"dlp":                     {"cloudstoragepathstoredinfotype"},
56: 		"dns":                     {"dnsrecordset"},
57: 		"edgecontainer":           {"edgecontainercluster"},
 filename:pkg/test/constants/presubmitconstants.go matching_line:		"dlp":                     {"cloudstoragepathstoredinfotype"},] map[context:21: 
22: 	operatorv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/apis/core/v1beta1"
23: 	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
24: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis"
25: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/test"
 filename:pkg/test/environment/environment.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"] map[context:26: )
27: 
28: // IDEA: Load all the samples, and check that we have all the KRM paths covered
29: 
30: func FillWithRandom(t *testing.T, randStream *rand.Rand, msg proto.Message) {
 filename:pkg/test/fuzz/generate.go matching_line:// IDEA: Load all the samples, and check that we have all the KRM paths covered] map[context:26: 		SkipUpdate: true,
27: 	}
28: 	resourceContextMap["cloudstoragepathstoredinfotype"] = ResourceContext{
29: 		ResourceKind: "DLPStoredInfoType",
30: 		// There is no update method for this resource.
 filename:pkg/test/resourcefixture/contexts/dlp_context.go matching_line:	resourceContextMap["cloudstoragepathstoredinfotype"] = ResourceContext{] map[context:13: // limitations under the License.
14: 
15: package pathslice
16: 
17: import "strings"
 filename:pkg/util/pathslice/pathslice.go matching_line:package pathslice] map[context:83: 
84: // Write does an atomic projection of the given payload into the writer's target
85: // directory.  Input paths must not begin with '..'.
86: //
87: // The Write algorithm is:
 filename:pkg/webhook/cert/writer/atomic/atomic_writer.go matching_line:// directory.  Input paths must not begin with '..'.] map[context:37: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/servicemapping/servicemappingloader"
38: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/text"
39: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"
40: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/typeutil"
41: 
 filename:pkg/webhook/immutable_fields_validator.go matching_line:	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/util/pathslice"] map[context:550: }
551: 
552: // findLinksInEvent looks for link paths and feeds the values into replacement.ExtractIDsFromLinks
553: func findLinksInEvent(t *testing.T, replacement *Replacements, event *test.LogEntry) {
554: 	linkPaths := sets.New(
 filename:tests/e2e/normalize.go matching_line:// findLinksInEvent looks for link paths and feeds the values into replacement.ExtractIDsFromLinks] map[context:453: // for a given test, allowing for recording of HTTP interactions.
454: // Why this exists: schema.Provider.ConfigureFunc is called multiple times for a given test
455: // ConfigureFunc on our provider creates a new HTTP client and sets base paths (config.go LoadAndValidate)
456: // VCR requires a single HTTP client to handle all interactions so it can record and replay responses so
457: // this caches HTTP clients per test by replacing ConfigureFunc
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/acctest/vcr_utils.go matching_line:// ConfigureFunc on our provider creates a new HTTP client and sets base paths (config.go LoadAndValidate)] map[context:50: 	UserProjectOverride        types.Bool
51: 
52: 	// paths for client setup
53: 	AccessApprovalBasePath           string
54: 	AccessContextManagerBasePath     string
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go matching_line:	// paths for client setup] map[context:17: 
18: // Methods to create new services from config
19: // Some base paths below need the version and possibly more of the path
20: // set on them. The client libraries are inconsistent about which values they need;
21: // while most only want the host URL, some older ones also want the version and some
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_provider_clients.go matching_line:// Some base paths below need the version and possibly more of the path] map[context:639: 										Type:        schema.TypeString,
640: 										Optional:    true,
641: 										Description: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,
642: 									},
643: 								},
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/appengine/resource_app_engine_flexible_app_version.go matching_line:										Description: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,] map[context:329: 										Type:        schema.TypeString,
330: 										Optional:    true,
331: 										Description: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,
332: 									},
333: 								},
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/appengine/resource_app_engine_standard_app_version.go matching_line:										Description: `Regular expression that matches the file paths for all files that should be referenced by this handler.`,] map[context:1429: 	kmsKeyName := v.(map[string]interface{})["kmsKeyName"].(string)
1430: 	re := regexp.MustCompile(`(projects/.*/locations/.*/keyRings/.*/cryptoKeys/.*)/cryptoKeyVersions/.*`)
1431: 	paths := re.FindStringSubmatch(kmsKeyName)
1432: 
1433: 	if len(paths) > 0 {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/bigquery/resource_bigquery_job.go matching_line:	paths := re.FindStringSubmatch(kmsKeyName)] map[context:2069: func flattenEncryptionConfiguration(ec *bigquery.EncryptionConfiguration) []map[string]interface{} {
2070: 	re := regexp.MustCompile(`(projects/.*/locations/.*/keyRings/.*/cryptoKeys/.*)/cryptoKeyVersions/.*`)
2071: 	paths := re.FindStringSubmatch(ec.KmsKeyName)
2072: 
2073: 	if len(paths) > 0 {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/bigquery/resource_bigquery_table.go matching_line:	paths := re.FindStringSubmatch(ec.KmsKeyName)] map[context:89: 										Type:     schema.TypeString,
90: 										Optional: true,
91: 										Description: `PEM intermediate certificate used for building up paths for validation.
92: Each certificate provided in PEM format may occupy up to 5kB.`,
93: 										Sensitive: true,
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/certificatemanager/resource_certificate_manager_trust_config.go matching_line:										Description: `PEM intermediate certificate used for building up paths for validation.] map[context:374: 													Description: `Path at which to mount the volume.
375: 
376: Paths must be absolute and cannot conflict with other volume paths on
377: the same build step or with certain reserved volume paths.`,
378: 												},
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger.go matching_line:Paths must be absolute and cannot conflict with other volume paths on] map[context:154:       objects {
155:         location = "gs://bucket/path/to/somewhere/"
156:         paths = ["path"]
157:       }
158:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger_generated_test.go matching_line:        paths = ["path"]] map[context:267:       objects {
268:         location = "gs://bucket/path/to/somewhere/"
269:         paths = ["path"]
270:       }
271:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudbuild/resource_cloudbuild_trigger_test.go matching_line:        paths = ["path"]] map[context:429: 							Type:        schema.TypeString,
430: 							Required:    true,
431: 							Description: `The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".`,
432: 						},
433: 						"project_id": {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudfunctions/resource_cloudfunctions_function.go matching_line:							Description: `The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".`,] map[context:907:     // here. If this test is run outside of CI, you may need to create your own
908:     // source repo.
909:     url = "https://source.developers.google.com/projects/%s/repos/cloudfunctions-test-do-not-delete/moveable-aliases/master/paths/"
910:   }
911: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/cloudfunctions/resource_cloudfunctions_function_test.go matching_line:    url = "https://source.developers.google.com/projects/%s/repos/cloudfunctions-test-do-not-delete/moveable-aliases/master/paths/"] map[context:1820:   host_rule {
1821:     hosts        = ["mysite.com"]
1822:     path_matcher = "allpaths"
1823:   }
1824: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_backend_service_test.go matching_line:    path_matcher = "allpaths"] map[context:1239: 		}
1240: 
1241: 		url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/disks/{{name}}?paths=provisionedIops")
1242: 		if err != nil {
1243: 			return err
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_disk.go matching_line:		url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/disks/{{name}}?paths=provisionedIops")] map[context:436:   host_rule {
437:     hosts        = ["mysite.com"]
438:     path_matcher = "allpaths"
439:   }
440: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_global_forwarding_rule_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:207:     name            = "boop"
208:     path_rule {
209:       paths   = ["/*"]
210:       service = google_compute_backend_service.backend.self_link
211:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_global_forwarding_rule_test.go matching_line:      paths   = ["/*"]] map[context:874: 
875: 	for k, v := range expected {
876: 		// source is the only self link, so compare by relpaths if source is being
877: 		// compared
878: 		if strings.HasSuffix(k, "source") {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_instance_migrate_test.go matching_line:		// source is the only self link, so compare by relpaths if source is being] map[context:79:   host_rule {
80:     hosts        = ["sslcert.tf-test.club"]
81:     path_matcher = "allpaths"
82:   }
83: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_managed_ssl_certificate_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:198:   host_rule {
199:     hosts        = ["mysite.com"]
200:     path_matcher = "allpaths"
201:   }
202: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_ssl_certificate_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:71:   host_rule {
72:     hosts        = ["mysite.com"]
73:     path_matcher = "allpaths"
74:   }
75: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_http_proxy_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:78:     name            = "boop"
79:     path_rule {
80:       paths   = ["/*"]
81:       service = google_compute_region_backend_service.foobar.self_link
82:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_http_proxy_test.go matching_line:      paths   = ["/*"]] map[context:81:   host_rule {
82:     hosts        = ["mysite.com"]
83:     path_matcher = "allpaths"
84:   }
85: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_https_proxy_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:97:     name            = "boop"
98:     path_rule {
99:       paths   = ["/*"]
100:       service = google_compute_region_backend_service.foobar1.self_link
101:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_target_https_proxy_test.go matching_line:      paths   = ["/*"]] map[context:697: are specified does not matter. Matches are always done on the longest-path-first
698: basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
699: irrespective of the order in which those paths appear in this list. Within a
700: given pathMatcher, only one of pathRules or routeRules must be set.`,
701: 							Elem: &schema.Resource{
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map.go matching_line:irrespective of the order in which those paths appear in this list. Within a] map[context:68:   host_rule {
69:     hosts        = ["mysite.com"]
70:     path_matcher = "allpaths"
71:   }
72: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:264: 
265:     path_rule {
266:       paths   = ["/*"]
267:       service = google_compute_region_backend_service.foobar.self_link
268:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_region_url_map_test.go matching_line:      paths   = ["/*"]] map[context:1131: 			// add added projects to updateMask
1132: 			if firstProject != true {
1133: 				maskId = fmt.Sprintf("%s%s", "&paths=shareSettings.projectMap.", original["project_id"])
1134: 			} else {
1135: 				maskId = fmt.Sprintf("%s%s", "?paths=shareSettings.projectMap.", original["project_id"])
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_reservation.go matching_line:				maskId = fmt.Sprintf("%s%s", "&paths=shareSettings.projectMap.", original["project_id"])] map[context:192:   host_rule {
193:     hosts        = ["mysite.com"]
194:     path_matcher = "allpaths"
195:   }
196: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_ssl_certificate_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:70:   host_rule {
71:     hosts        = ["mysite.com"]
72:     path_matcher = "allpaths"
73:   }
74:   path_matcher {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_grpc_proxy_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:59:   host_rule {
60:     hosts        = ["mysite.com"]
61:     path_matcher = "allpaths"
62:   }
63:   path_matcher {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_grpc_proxy_test.go matching_line:    path_matcher = "allpaths"] map[context:69:   host_rule {
70:     hosts        = ["mysite.com"]
71:     path_matcher = "allpaths"
72:   }
73: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_http_proxy_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:104:     name            = "boop"
105:     path_rule {
106:       paths   = ["/*"]
107:       service = google_compute_backend_service.foobar.self_link
108:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_http_proxy_test.go matching_line:      paths   = ["/*"]] map[context:78:   host_rule {
79:     hosts        = ["mysite.com"]
80:     path_matcher = "allpaths"
81:   }
82: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_https_proxy_generated_test.go matching_line:    path_matcher = "allpaths"] map[context:179:     name            = "boop"
180:     path_rule {
181:       paths   = ["/*"]
182:       service = google_compute_backend_service.foobar.self_link
183:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_target_https_proxy_test.go matching_line:      paths   = ["/*"]] map[context:1135: 							Optional:         true,
1136: 							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
1137: 							Description:      `The backend service or backend bucket to use when none of the given paths match.`,
1138: 						},
1139: 						"default_url_redirect": {
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map.go matching_line:							Description:      `The backend service or backend bucket to use when none of the given paths match.`,] map[context:71:   host_rule {
72:     hosts        = ["myothersite.com"]
73:     path_matcher = "otherpaths"
74:   }
75: 
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map_generated_test.go matching_line:    path_matcher = "otherpaths"] map[context:393: 
394:     path_rule {
395:       paths   = ["/*"]
396:       service = google_compute_backend_service.foobar.self_link
397:     }
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/compute/resource_compute_url_map_test.go matching_line:      paths   = ["/*"]] map[context:250: 																			Type:     schema.TypeList,
251: 																			Optional: true,
252: 																			Description: `A list of regular expressions matching file paths to exclude. All files in the bucket that match at
253: least one of these regular expressions will be excluded from the scan.`,
254: 																			Elem: &schema.Schema{
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/datalossprevention/resource_data_loss_prevention_job_trigger.go matching_line:																			Description: `A list of regular expressions matching file paths to exclude. All files in the bucket that match at] map[context:2064: 				Required:    true,
2065: 				ForceNew:    true,
2066: 				Description: "Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args",
2067: 				Elem:        &schema.Schema{Type: schema.TypeString},
2068: 			},
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/dataproc/resource_dataproc_workflow_template.go matching_line:				Description: "Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args",] map[context:90: func resourceDatastreamStreamDatabaseIdDiffSuppress(_, old, new string, _ *schema.ResourceData) bool {
91: 	re := regexp.MustCompile(`projects/(.+)/datasets/([^\.\?\#]+)`)
92: 	paths := re.FindStringSubmatch(new)
93: 
94: 	// db returns value in form <project>:<dataset_id>
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/datastream/resource_datastream_stream.go matching_line:	paths := re.FindStringSubmatch(new)] map[context:129: 										Type:        schema.TypeList,
130: 										Required:    true,
131: 										Description: `The routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.`,
132: 										MinItems:    1,
133: 										MaxItems:    200,
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/networkservices/resource_network_services_edge_cache_service.go matching_line:										Description: `The routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.`,] map[context:80: schemes:
81: - "https"
82: paths:
83:   "/echo":
84:     post:
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/servicemanagement/resource_endpoints_service_test.go matching_line:paths:] map[context:237: 							Type:        schema.TypeList,
238: 							Computed:    true,
239: 							Description: `Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.`,
240: 							Elem: &schema.Resource{
241: 								Schema: map[string]*schema.Schema{
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/vertexai/resource_vertex_ai_endpoint.go matching_line:							Description: `Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.`,] map[context:14: )
15: 
16: // Compare only the resource name of two self links/paths.
17: func CompareResourceNames(_, old, new string, _ *schema.ResourceData) bool {
18: 	return GetResourceNameFromSelfLink(old) == GetResourceNameFromSelfLink(new)
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource/self_link_helpers.go matching_line:// Compare only the resource name of two self links/paths.] map[context:452: const TagsLocationBasePathKey = "TagsLocation"
453: 
454: // Generated product base paths
455: var DefaultBasePaths = map[string]string{
456: 	AccessApprovalBasePathKey:           "https://accessapproval.googleapis.com/v1/",
 filename:third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go matching_line:// Generated product base paths]] result:success]}]
I0219 07:05:33.395619  460137 chat.go:96] UsageMetadata: &{PromptTokenCount:28282 CandidatesTokenCount:71 TotalTokenCount:28353}
I0219 07:05:33.395659  460137 chat.go:107] processing candidate &{candidate:0xc000174f00}
functionCall: {Name:EditFile Arguments:map[existing_text:	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.BasicDiff) filename:pkg/controller/direct/migrationcenter/group_controller.go new_text:	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.ProtoCompareBasicDiff)]}
I0219 07:05:33.395885  460137 tool_edit_file.go:116] wrote /usr/local/google/home/yuwenma/go/src/github.com/GoogleCloudPlatform/migrationcenter-Group/pkg/controller/direct/migrationcenter/group_controller.go: // Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package migrationcenter

import (
	migrationcenterapiv1 "cloud.google.com/go/migrationcenter/apiv1"
	"context"
	"fmt"

	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"

	// TODO(contributor): Update the import with the google cloud client
	gcp "cloud.google.com/go/migrationcenter/apiv1"

	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func init() {
	registry.RegisterModel(krm.MigrationcenterGroupGVK, NewGroupModel)
}

func NewGroupModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
	return &modelGroup{config: *config}, nil
}

var _ directbase.Model = &modelGroup{}

type modelGroup struct {
	config config.ControllerConfig
}

func (m *modelGroup) client(ctx context.Context) (*gcp.Client, error) {
	var opts []option.ClientOption
	opts, err := m.config.RESTClientOptions()
	if err != nil {
		return nil, err
	}
	gcpClient, err := gcp.NewRESTClient(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("building Group client: %w", err)
	}
	return gcpClient, err
}

func (m *modelGroup) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
	obj := &krm.MigrationcenterGroup{}
	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &obj); err != nil {
		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
	}

	id, err := krm.NewGroupIdentity(ctx, reader, obj)
	if err != nil {
		return nil, err
	}

	// Get migrationcenter GCP client
	gcpClient, err := m.client(ctx)
	if err != nil {
		return nil, err
	}
	return &GroupAdapter{
		id:        id,
		gcpClient: gcpClient,
		desired:   obj,
	}, nil
}

func (m *modelGroup) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
	// TODO: Support URLs
	return nil, nil
}

type GroupAdapter struct {
	id        *krm.GroupIdentity
	gcpClient *gcp.Client
	desired   *krm.MigrationcenterGroup
	actual    *migrationcenterapiv1.Group
}

var _ directbase.Adapter = &GroupAdapter{}

// Find retrieves the GCP resource.
// Return true means the object is found. This triggers Adapter `Update` call.
// Return false means the object is not found. This triggers Adapter `Create` call.
// Return a non-nil error requeues the requests.
func (a *GroupAdapter) Find(ctx context.Context) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("getting Group", "name", a.id)

	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
	grouppb, err := a.gcpClient.GetGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			return false, nil
		}
		return false, fmt.Errorf("getting Group %q: %w", a.id, err)
	}

	a.actual = grouppb
	return true, nil
}

// Create creates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("creating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desired := a.desired.DeepCopy()
	resource := MigrationcenterGroupSpec_ToProto(mapCtx, &desired.Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	// TODO(contributor): Complete the gcp "CREATE" or "INSERT" request.
	req := &migrationcenterpb.CreateGroupRequest{
		Parent: a.id.Parent().String(),
		Group:  resource,
	}
	op, err := a.gcpClient.CreateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("creating Group %s: %w", a.id, err)
	}
	created, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting creation: %w", a.id, err)
	}
	log.V(2).Info("successfully created Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, created)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	status.ExternalRef = direct.LazyPtr(a.id.String())
	return createOp.UpdateStatus(ctx, status, nil)
}

// Update updates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("updating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desiredPb := MigrationcenterGroupSpec_ToProto(mapCtx, &a.desired.DeepCopy().Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	var err error
	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.ProtoCompareBasicDiff)
	if err != nil {
		return err
	}
	if len(paths) == 0 {
		log.V(2).Info("no field needs update", "name", a.id)
		status := &krm.MigrationcenterGroupStatus{}
		status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, a.actual)
		if mapCtx.Err() != nil {
			return mapCtx.Err()
		}
		return updateOp.UpdateStatus(ctx, status, nil)
	}
	updateMask := &fieldmaskpb.FieldMask{
		Paths: sets.List(paths)}

	// TODO(contributor): Complete the gcp "UPDATE" or "PATCH" request.
	req := &migrationcenterpb.UpdateGroupRequest{
		Name:       a.id,
		UpdateMask: updateMask,
		Group:      desiredPb,
	}
	op, err := a.gcpClient.UpdateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("updating Group %s: %w", a.id, err)
	}
	updated, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting update: %w", a.id, err)
	}
	log.V(2).Info("successfully updated Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, updated)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	return updateOp.UpdateStatus(ctx, status, nil)
}

// Export maps the GCP object to a Config Connector resource `spec`.
func (a *GroupAdapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
	if a.actual == nil {
		return nil, fmt.Errorf("Find() not called")
	}
	u := &unstructured.Unstructured{}

	obj := &krm.MigrationcenterGroup{}
	mapCtx := &direct.MapContext{}
	obj.Spec = direct.ValueOf(MigrationcenterGroupSpec_FromProto(mapCtx, a.actual))
	if mapCtx.Err() != nil {
		return nil, mapCtx.Err()
	}
	obj.Spec.ProjectRef = &refs.ProjectRef{External: a.id.Parent().ProjectID}
	obj.Spec.Location = a.id.Parent().Location
	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
	if err != nil {
		return nil, err
	}

	u.SetName(a.actual.Id)
	u.SetGroupVersionKind(krm.MigrationcenterGroupGVK)

	u.Object = uObj
	return u, nil
}

// Delete the resource from GCP service when the corresponding Config Connector resource is deleted.
func (a *GroupAdapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("deleting Group", "name", a.id)

	req := &migrationcenterpb.DeleteGroupRequest{Name: a.id.String()}
	op, err := a.gcpClient.DeleteGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			// Return success if not found (assume it was already deleted).
			log.V(2).Info("skipping delete for non-existent Group, assuming it was already deleted", "name", a.id.String())
			return true, nil
		}
		return false, fmt.Errorf("deleting Group %s: %w", a.id, err)
	}
	log.V(2).Info("successfully deleted Group", "name", a.id)

	err = op.Wait(ctx)
	if err != nil {
		return false, fmt.Errorf("waiting delete Group %s: %w", a.id, err)
	}
	return true, nil
}
sending response: {"success":true}
I0219 07:05:33.395913  460137 chat.go:157] functionResponses: [{Name:EditFile Result:map[success:true]}]
running *ui.BashUI: error running callback: generating content with gemini: sending message to LLM: rpc error: code = ResourceExhausted desc = Resource exhausted. Please try again later. Please refer to https://cloud.google.com/vertex-ai/generative-ai/docs/error-code-429 for more details.
error details: name = DebugInfo detail = INTERNAL: Fail to execute model for flow_id: flow_runner_text_lora_us_TEXT_32k_1m
Error: You are most probably getting throttled by Servomatic. If you are sending batch traffic, please follow the guidelines at http://go/servo-faq#batch_traffic. If this is a smooth traffic ramp-up, we should be able to autoscale up. (old status: extensible_stubs::OVERLOADED_TOO_MANY_RETRIES_PER_REQUEST: A retryable error could not be retried due to too many retries per Extensible Stubs request (see go/xs-retries-per-request). (old status: generic::unavailable: Overloaded prefill queue.); RetryingStub: [attempts:3] [production.rpc.stubs.proto.ExtensibleStubsBackendErrors] { errors { code: 14 space: "generic" message: "Overloaded prefill queue." } }); [monitoring=main-model,model=/aistudio/gemini-v3m-glp-2m,target=CloudLargeModels_LanguageModels_uniserve_prod] [type.googleapis.com/util.ErrorSpacePayload='extensible_stubs::OVERLOADED_TOO_MANY_RETRIES_PER_REQUEST'] [type.googleapis.com/util.MessageSetPayload='[production.rpc.stubs...(length 2908) stack =
I0219 07:06:51.092801  779200 vertexai.go:238] "sending LLM request" user=["\"You are a very good golang programmer and good at doing tasks.Your task is to make the given go code compilable:- run go build ./pkg/controller/direct/migrationcenter/... and fix all the errors.- run go build ./apis/migrationcenter/v1alpha1/... and fix all the errors.- Edit the existing files if needed.- Add new files if needed. New file should only be added under ./apis/migrationcenter/v1alpha1/ or ./pkg/controller/direct/migrationcenter/ directories.- Retry max to 10 times or until you succeed. - Once you fixed the go build errors, print the message in Json format- If you see imported ... not used, you should remove the unused import package.{status: success}\""]
I0219 07:07:02.529813  779200 chat.go:96] UsageMetadata: &{PromptTokenCount:853 CandidatesTokenCount:286 TotalTokenCount:1139}
I0219 07:07:02.529858  779200 chat.go:107] processing candidate &{candidate:0xc008494320}
Okay, I will follow your instructions to fix the go build errors for the provided packages. I will use the available tools to iteratively build, identify errors, and apply fixes until the build succeeds. I will prioritize editing existing files and only create new files under the specified directories when necessary.

Here's the plan:

1. **Initial Build Attempt:** I will start by running the `go build` commands for both packages as instructed.
2. **Error Analysis:** I'll analyze the output of the build commands to identify the specific errors, including file names, line numbers, and error messages.
3. **Targeted Fixes:** Based on the errors, I will use the `EditFile` or `CreateFile` tools to apply the necessary code changes. I will focus on one error at a time, starting with the simplest issues like unused imports or syntax errors.
4. **Iterative Process:** I will repeat steps 1-3, iteratively building and fixing errors until both `go build` commands succeed without any errors.
5. **Success Confirmation:** Once both builds are successful, I will print the success message in the requested JSON format.

Let's start with the first build attempt.


functionCall: {Name:RunTerminalCommand Arguments:map[args:build ./pkg/controller/direct/migrationcenter/... command:go]}
sending response: {"error":"command failed with exit code 1: ","output":"# github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/migrationcenter\npkg/controller/direct/migrationcenter/group_controller.go:102:34: undefined: migrationcenterapiv1.Group\npkg/controller/direct/migrationcenter/group_controller.go:115:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:141:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:176:2: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:176:70: undefined: common.ProtoCompareBasicDiff\npkg/controller/direct/migrationcenter/group_controller.go:180:9: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:190:20: undefined: paths\npkg/controller/direct/migrationcenter/group_controller.go:193:10: undefined: migrationcenterpb\npkg/controller/direct/migrationcenter/group_controller.go:248:10: undefined: migrationcenterpb\n","success":false}
functionCall: {Name:RunTerminalCommand Arguments:map[args:build ./apis/migrationcenter/v1alpha1/... command:go]}
sending response: {"error":"","output":"","success":true}
I0219 07:07:03.170233  779200 chat.go:157] functionResponses: [{Name:RunTerminalCommand Result:map[error:command failed with exit code 1:  output:# github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/migrationcenter
pkg/controller/direct/migrationcenter/group_controller.go:102:34: undefined: migrationcenterapiv1.Group
pkg/controller/direct/migrationcenter/group_controller.go:115:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:141:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:176:2: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:176:70: undefined: common.ProtoCompareBasicDiff
pkg/controller/direct/migrationcenter/group_controller.go:180:9: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:190:20: undefined: paths
pkg/controller/direct/migrationcenter/group_controller.go:193:10: undefined: migrationcenterpb
pkg/controller/direct/migrationcenter/group_controller.go:248:10: undefined: migrationcenterpb
 success:false]} {Name:RunTerminalCommand Result:map[error: output: success:true]}]
I0219 07:07:12.753462  779200 chat.go:96] UsageMetadata: &{PromptTokenCount:1437 CandidatesTokenCount:160 TotalTokenCount:1597}
I0219 07:07:12.753500  779200 chat.go:107] processing candidate &{candidate:0xc0084043c0}
Okay, the first build attempt revealed several errors in `pkg/controller/direct/migrationcenter/group_controller.go`. The errors indicate undefined references to:

-   `migrationcenterapiv1.Group`
-   `migrationcenterpb` (likely a protobuf definition)
-   `paths`
-   `common.ProtoCompareBasicDiff`

The second build command for `./apis/migrationcenter/v1alpha1/...` succeeded, meaning there are no errors in that package at this moment.

Let's address the errors in `group_controller.go`. First I'll try to locate the `migrationcenterapiv1.Group` definition in the project.


functionCall: {Name:FindInWorkspace Arguments:map[find_text:migrationcenterapiv1.Group]}
sending response: {"matches":[{"context":"100: \tgcpClient *gcp.Client\n101: \tdesired   *krm.MigrationcenterGroup\n102: \tactual    *migrationcenterapiv1.Group\n103: }\n104: \n","filename":"pkg/controller/direct/migrationcenter/group_controller.go","matching_line":"\tactual    *migrationcenterapiv1.Group"}],"result":"success"}
I0219 07:07:13.145743  779200 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:[map[context:100: 	gcpClient *gcp.Client
101: 	desired   *krm.MigrationcenterGroup
102: 	actual    *migrationcenterapiv1.Group
103: }
104: 
 filename:pkg/controller/direct/migrationcenter/group_controller.go matching_line:	actual    *migrationcenterapiv1.Group]] result:success]}]
I0219 07:07:22.671943  779200 chat.go:96] UsageMetadata: &{PromptTokenCount:1691 CandidatesTokenCount:125 TotalTokenCount:1816}
I0219 07:07:22.671984  779200 chat.go:107] processing candidate &{candidate:0xc007da2aa0}
It seems `migrationcenterapiv1.Group` is used in the same file where it is reported missing (`pkg/controller/direct/migrationcenter/group_controller.go`). This is odd, as the error suggests it's undefined. The issue might stem from an incorrect import path for `migrationcenterapiv1`. The build output suggests the correct package might be within `k8s-config-connector`, but it is not being used in the controller file.

I will investigate `migrationcenterpb` next as it is probably a dependency.


functionCall: {Name:FindInWorkspace Arguments:map[find_text:migrationcenterpb]}
sending response: {"matches":[{"context":"113: \tlog.V(2).Info(\"getting Group\", \"name\", a.id)\n114: \n115: \treq := \u0026migrationcenterpb.GetGroupRequest{Name: a.id.String()}\n116: \tgrouppb, err := a.gcpClient.GetGroup(ctx, req)\n117: \tif err != nil {\n","filename":"pkg/controller/direct/migrationcenter/group_controller.go","matching_line":"\treq := \u0026migrationcenterpb.GetGroupRequest{Name: a.id.String()}"},{"context":"16: \n17: import (\n18: \tpb \"cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb\"\n19: \tkrm \"github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1\"\n20: \t\"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct\"\n","filename":"pkg/controller/direct/migrationcenter/mapper.generated.go","matching_line":"\tpb \"cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb\""}],"result":"success"}
I0219 07:07:23.080656  779200 chat.go:157] functionResponses: [{Name:FindInWorkspace Result:map[matches:[map[context:113: 	log.V(2).Info("getting Group", "name", a.id)
114: 
115: 	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
116: 	grouppb, err := a.gcpClient.GetGroup(ctx, req)
117: 	if err != nil {
 filename:pkg/controller/direct/migrationcenter/group_controller.go matching_line:	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}] map[context:16: 
17: import (
18: 	pb "cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb"
19: 	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
20: 	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
 filename:pkg/controller/direct/migrationcenter/mapper.generated.go matching_line:	pb "cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb"]] result:success]}]
I0219 07:07:33.149458  779200 chat.go:96] UsageMetadata: &{PromptTokenCount:2097 CandidatesTokenCount:229 TotalTokenCount:2326}
I0219 07:07:33.149494  779200 chat.go:107] processing candidate &{candidate:0xc008494d20}
Okay, `migrationcenterpb` is found in `pkg/controller/direct/migrationcenter/group_controller.go` and `pkg/controller/direct/migrationcenter/mapper.generated.go`. It seems the correct import should be `"cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb"`. The controller file doesn't import anything, so that must be the problem. Let's add this import to the controller.


functionCall: {Name:EditFile Arguments:map[existing_text:package migrationcenter filename:pkg/controller/direct/migrationcenter/group_controller.go new_text:package migrationcenter

import (
	"cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb"
	migrationcenterapiv1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/common"
	"k8s-config-connector/pkg/util/paths"
)
]}
I0219 07:07:33.149695  779200 tool_edit_file.go:116] wrote /usr/local/google/home/yuwenma/go/src/github.com/GoogleCloudPlatform/migrationcenter-Group/pkg/controller/direct/migrationcenter/group_controller.go: // Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package migrationcenter

import (
	"cloud.google.com/go/migrationcenter/apiv1/migrationcenterpb"
	migrationcenterapiv1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/common"
	"k8s-config-connector/pkg/util/paths"
)


import (
	migrationcenterapiv1 "cloud.google.com/go/migrationcenter/apiv1"
	"context"
	"fmt"

	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/migrationcenter/v1alpha1"
	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"

	// TODO(contributor): Update the import with the google cloud client
	gcp "cloud.google.com/go/migrationcenter/apiv1"

	"google.golang.org/api/option"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func init() {
	registry.RegisterModel(krm.MigrationcenterGroupGVK, NewGroupModel)
}

func NewGroupModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
	return &modelGroup{config: *config}, nil
}

var _ directbase.Model = &modelGroup{}

type modelGroup struct {
	config config.ControllerConfig
}

func (m *modelGroup) client(ctx context.Context) (*gcp.Client, error) {
	var opts []option.ClientOption
	opts, err := m.config.RESTClientOptions()
	if err != nil {
		return nil, err
	}
	gcpClient, err := gcp.NewRESTClient(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("building Group client: %w", err)
	}
	return gcpClient, err
}

func (m *modelGroup) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
	obj := &krm.MigrationcenterGroup{}
	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &obj); err != nil {
		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
	}

	id, err := krm.NewGroupIdentity(ctx, reader, obj)
	if err != nil {
		return nil, err
	}

	// Get migrationcenter GCP client
	gcpClient, err := m.client(ctx)
	if err != nil {
		return nil, err
	}
	return &GroupAdapter{
		id:        id,
		gcpClient: gcpClient,
		desired:   obj,
	}, nil
}

func (m *modelGroup) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
	// TODO: Support URLs
	return nil, nil
}

type GroupAdapter struct {
	id        *krm.GroupIdentity
	gcpClient *gcp.Client
	desired   *krm.MigrationcenterGroup
	actual    *migrationcenterapiv1.Group
}

var _ directbase.Adapter = &GroupAdapter{}

// Find retrieves the GCP resource.
// Return true means the object is found. This triggers Adapter `Update` call.
// Return false means the object is not found. This triggers Adapter `Create` call.
// Return a non-nil error requeues the requests.
func (a *GroupAdapter) Find(ctx context.Context) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("getting Group", "name", a.id)

	req := &migrationcenterpb.GetGroupRequest{Name: a.id.String()}
	grouppb, err := a.gcpClient.GetGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			return false, nil
		}
		return false, fmt.Errorf("getting Group %q: %w", a.id, err)
	}

	a.actual = grouppb
	return true, nil
}

// Create creates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("creating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desired := a.desired.DeepCopy()
	resource := MigrationcenterGroupSpec_ToProto(mapCtx, &desired.Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	// TODO(contributor): Complete the gcp "CREATE" or "INSERT" request.
	req := &migrationcenterpb.CreateGroupRequest{
		Parent: a.id.Parent().String(),
		Group:  resource,
	}
	op, err := a.gcpClient.CreateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("creating Group %s: %w", a.id, err)
	}
	created, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting creation: %w", a.id, err)
	}
	log.V(2).Info("successfully created Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, created)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	status.ExternalRef = direct.LazyPtr(a.id.String())
	return createOp.UpdateStatus(ctx, status, nil)
}

// Update updates the resource in GCP based on `spec` and update the Config Connector object `status` based on the GCP response.
func (a *GroupAdapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
	log := klog.FromContext(ctx)
	log.V(2).Info("updating Group", "name", a.id)
	mapCtx := &direct.MapContext{}

	desiredPb := MigrationcenterGroupSpec_ToProto(mapCtx, &a.desired.DeepCopy().Spec)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}

	var err error
	paths, err = common.CompareProtoMessage(desiredPb, a.actual, common.ProtoCompareBasicDiff)
	if err != nil {
		return err
	}
	if len(paths) == 0 {
		log.V(2).Info("no field needs update", "name", a.id)
		status := &krm.MigrationcenterGroupStatus{}
		status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, a.actual)
		if mapCtx.Err() != nil {
			return mapCtx.Err()
		}
		return updateOp.UpdateStatus(ctx, status, nil)
	}
	updateMask := &fieldmaskpb.FieldMask{
		Paths: sets.List(paths)}

	// TODO(contributor): Complete the gcp "UPDATE" or "PATCH" request.
	req := &migrationcenterpb.UpdateGroupRequest{
		Name:       a.id,
		UpdateMask: updateMask,
		Group:      desiredPb,
	}
	op, err := a.gcpClient.UpdateGroup(ctx, req)
	if err != nil {
		return fmt.Errorf("updating Group %s: %w", a.id, err)
	}
	updated, err := op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("Group %s waiting update: %w", a.id, err)
	}
	log.V(2).Info("successfully updated Group", "name", a.id)

	status := &krm.MigrationcenterGroupStatus{}
	status.ObservedState = MigrationcenterGroupObservedState_FromProto(mapCtx, updated)
	if mapCtx.Err() != nil {
		return mapCtx.Err()
	}
	return updateOp.UpdateStatus(ctx, status, nil)
}

// Export maps the GCP object to a Config Connector resource `spec`.
func (a *GroupAdapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
	if a.actual == nil {
		return nil, fmt.Errorf("Find() not called")
	}
	u := &unstructured.Unstructured{}

	obj := &krm.MigrationcenterGroup{}
	mapCtx := &direct.MapContext{}
	obj.Spec = direct.ValueOf(MigrationcenterGroupSpec_FromProto(mapCtx, a.actual))
	if mapCtx.Err() != nil {
		return nil, mapCtx.Err()
	}
	obj.Spec.ProjectRef = &refs.ProjectRef{External: a.id.Parent().ProjectID}
	obj.Spec.Location = a.id.Parent().Location
	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
	if err != nil {
		return nil, err
	}

	u.SetName(a.actual.Id)
	u.SetGroupVersionKind(krm.MigrationcenterGroupGVK)

	u.Object = uObj
	return u, nil
}

// Delete the resource from GCP service when the corresponding Config Connector resource is deleted.
func (a *GroupAdapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
	log := klog.FromContext(ctx)
	log.V(2).Info("deleting Group", "name", a.id)

	req := &migrationcenterpb.DeleteGroupRequest{Name: a.id.String()}
	op, err := a.gcpClient.DeleteGroup(ctx, req)
	if err != nil {
		if direct.IsNotFound(err) {
			// Return success if not found (assume it was already deleted).
			log.V(2).Info("skipping delete for non-existent Group, assuming it was already deleted", "name", a.id.String())
			return true, nil
		}
		return false, fmt.Errorf("deleting Group %s: %w", a.id, err)
	}
	log.V(2).Info("successfully deleted Group", "name", a.id)

	err = op.Wait(ctx)
	if err != nil {
		return false, fmt.Errorf("waiting delete Group %s: %w", a.id, err)
	}
	return true, nil
}
sending response: {"success":true}
I0219 07:07:33.149726  779200 chat.go:157] functionResponses: [{Name:EditFile Result:map[success:true]}]
I0219 07:07:42.326796  779200 chat.go:96] UsageMetadata: &{PromptTokenCount:2329 CandidatesTokenCount:0 TotalTokenCount:2329}
I0219 07:07:42.326821  779200 chat.go:107] processing candidate &{candidate:0xc007da2d20}
